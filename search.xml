<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[java发散思维-矩阵算法案例]]></title>
      <url>%2F2018%2F06%2F26%2Fpro%2Fjava_jzmath%2F</url>
      <content type="text"><![CDATA[发散思维 发散思维（Divergent Thinking），又称辐射思维、放射思维、扩散思维或求异思维，是指大脑在思维时呈现的一种扩散状态的思维模式，它表现为思维视野广阔，思维呈现出多维发散状。如“一题多解”、“一事多写”、“一物多用”等方式，培养发散思维能力。 不少心理学家认为，发散思维是创造性思维的最主要的特点，是测定创造力的主要标志之一。 作为一名苦逼的程序员，思维是最重要的。编程这一行技术决定走多远，思维决定走多高。 已一个判断逻辑为例子,介绍线下思维判断和发散思维已矩阵形式判断一个应用应用考虑性能、安全、拓展、稳定等因素进行对比 传统线下思维代码 思维：多以一条从开始到结束一路走下去，循行渐进 代码：以 if else 一环套一环 一路一路匹配 优点：代码量少 缺点：代码难懂、难维护、难拓展、 发散思维 思维：已一个点向多个点发散，已网装形式思考，将一个大的问题，拆分多个小问题思考 代码：已模型的形式，将条件已build形式创建，将模型放入矩阵中匹配计算得出结果 优点：易懂、逻辑性强、好维护、好拓展、稳定性强、数据与逻辑好分离 缺点：代码稍多]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsp 标签报错]]></title>
      <url>%2F2018%2F04%2F10%2Fpro%2Fjsp%20%E6%8A%A5%E9%94%99%2F</url>
      <content type="text"><![CDATA[execl 内容替换 &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core“ %&gt;识别不了包，与报错 apache-tomcat-7.0.76\conf 修改中 catalina.properties 配置 将tomcat.util.scan.DefaultJarScanner.jarsToSkip=\, 上* 号去掉]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java poi模板内容替换]]></title>
      <url>%2F2017%2F11%2F15%2Fpro%2Fpoi%E6%A8%A1%E6%9D%BF%E6%9B%BF%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[execl 内容替换 获取execl 模板 设置模板特殊字符进行字符替换内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package com.bgy.tcd.ssm.util;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.poifs.filesystem.POIFSFileSystem;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import com.bgy.tcd.ssm.util.poiutils.ExecleHelper;/** * 替换execl数据 * @author Administrator * */public class PoiTest &#123; public POIFSFileSystem fs; HSSFWorkbook wb; Sheet sheet; Row row; public static void main(String[] args) throws FileNotFoundException, IOException &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;a_1&quot;, &quot;aaa&quot;); map.put(&quot;b_2&quot;, &quot;cccc&quot;); map.put(&quot;@title&quot;, &quot;X区域XXX项目过程管控风险预警单&quot;); map.put(&quot;@cb_1&quot;, &quot;a1&quot;); map.put(&quot;@ab_2&quot;, &quot;a2&quot;); map.put(&quot;@ab_3&quot;, &quot;a3&quot;); HSSFWorkbook hss = new PoiTest().replaceExcel(&quot;s1&quot;, &quot;F:/UpFile/abc.xls&quot;, map); //下载execl// ExecleHelper.outFile(response,wb, &quot;用户分析统计&quot;);// &#125; /** * 替换Excel模板中的数据 * * @param sheetName * Sheet名字 * @param modelPath * 模板路径 * @param param * 需要替换的数据 * @return */ public HSSFWorkbook replaceExcel(String sheetName, String modelPath, Map&lt;String, Object&gt; param) throws FileNotFoundException, IOException &#123; // 获取所读取excel模板的对象 try &#123; File file = new File(modelPath); if (!file.exists()) &#123; System.out.println(&quot;模板文件:&quot; + modelPath + &quot;不存在!&quot;); &#125; fs = new POIFSFileSystem(new FileInputStream(file)); wb = new HSSFWorkbook(fs); sheet = wb.getSheet(sheetName); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; replaceExcelDate(param); savePic(&quot;abbb.xls&quot;); return wb; &#125; /** * 根据 Map中的数据替换Excel模板中指定数据 * * @param param */ public void replaceExcelDate(Map&lt;String, Object&gt; param) &#123; // 获取行数 int rowNum = sheet.getLastRowNum(); System.out.println(&quot;rowNum:&quot;+rowNum); for (int i = 0; i &lt;= rowNum; i++) &#123; row = sheet.getRow(i); // 获取行里面的总列数 int columnNum = 0; if (row != null) &#123; columnNum = row.getLastCellNum(); &#125; System.out.println(&quot;columnNum:&quot;+columnNum); for (int j = 0; j &lt; columnNum; j++) &#123; Cell cell = sheet.getRow(i).getCell(j); if (cell != null) &#123; String cellValue = cell.getStringCellValue(); System.out.println(&quot;cellValue:&quot;+cellValue); for (Entry&lt;String, Object&gt; entry : param.entrySet()) &#123; String key = entry.getKey(); if (key.equals(cellValue)) &#123; String value = entry.getValue().toString(); setCellStrValue(i, j, value); &#125; &#125; &#125;else&#123; System.err.println(&quot;ii:&quot;+i+&quot;----jjj:&quot;+j); &#125; &#125; &#125; &#125; /** * 设置字符串类型的数据 * * @param rowIndex--行值 * 从0开始 * @param cellnum--列值 * 从0开始 * @param value--字符串类型的数据 * */ public void setCellStrValue(int rowIndex, int cellnum, String value) &#123; Row row = sheet.getRow(rowIndex); Cell cell = row.getCell(cellnum); if(cell==null) cell = sheet.getRow(rowIndex).createCell(cellnum); cell.setCellValue(value); &#125; private void savePic(String fileName) &#123; OutputStream os = null; try &#123; String path = &quot;F:\\UpFile\\&quot;; // 2、保存到临时文件 // 1K的数据缓冲 byte[] bs = new byte[1024]; // 读取到的数据长度 int len; // 输出的文件流保存到本地文件 File tempFile = new File(path); if (!tempFile.exists()) &#123; tempFile.mkdirs(); &#125; os = new FileOutputStream(tempFile.getPath() + File.separator + fileName); wb.write(os); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 完毕，关闭所有链接 try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java文件下载response header设置]]></title>
      <url>%2F2017%2F09%2F26%2Fpro%2Fjava%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BDheader%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@ResponseBody @RequestMapping(&quot;downLoad&quot;) public HttpServletResponse download(HttpServletRequest request,HttpServletResponse response,String fileName) throws UnsupportedEncodingException &#123;// fileName =&quot;a.png&quot;; fileName =&quot;b.mp4&quot;; System.out.println(&quot;fileName:&quot;+fileName); String bname = new String(fileName.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;); System.out.println(&quot;bname：&quot;+bname); try &#123; InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;config.properties&quot;); Properties properties = new Properties(); try &#123; properties.load(inputStream); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; String savePath = properties.getProperty(&quot;FilePath&quot;); String path = savePath+&quot;/&quot;+bname; try &#123; // path是指欲下载的文件的路径。 File file = new File(path); // 取得文件名。 String filename = file.getName(); // 取得文件的后缀名。 String ext = filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1).toUpperCase(); // 以流的形式下载文件。 InputStream fis = new BufferedInputStream(new FileInputStream(path)); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); // 设置response的Header// response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(filename.getBytes()));// response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);// response.setContentType(&quot;application/octet-stream;charset=UTF-8&quot;); // response.setContentType(&quot;image/jpeg&quot;); response.addHeader(&quot;Content-Type&quot;, &quot;video/mp4&quot;); response.addHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;); response.addHeader(&quot;Content-Range&quot;, &quot;bytes=0-&quot;); response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length()); toClient.write(buffer); toClient.flush(); toClient.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return response; &#125; catch (Exception e) &#123; log.error(&quot;下载失败：-&quot; + e.getMessage(), e); return response; &#125; &#125; 文件下载设置一下header1234 //设置response的Headerresponse.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(filename.getBytes()));response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);response.setContentType(&quot;application/octet-stream;charset=UTF-8&quot;); 图片浏览器静态预览（非下载图片文件） image格式设置成jpeg *或者png格式似乎是不支持浏览器静态预览，其他格式的话就没有尝试设置的jpeg格式并非图片文件格式，它是告诉浏览器该文件是什么类型所以所有图片设置该格式即可1response.setContentType(&quot;image/jpeg&quot;); 视频浏览器静态预览（非文件下载） ios 浏览器播放失败，目前未找到原因。最后解决办法静态访问视频资源1234response.addHeader(&quot;Content-Type&quot;, &quot;video/mp4&quot;);response.addHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);response.addHeader(&quot;Content-Range&quot;, &quot;bytes=0-&quot;);response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java html格式化]]></title>
      <url>%2F2017%2F08%2F04%2Fpro%2Fhtml%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[此文章教大家怎样将前端html优美的拼接数据在一次开发中我看到同事的代码是这样的 拼接输出的代码是这样的。整洁可读的格式化 再看一下我拼接的代码 揉在一起一坨屎html部分的可读性相当差当我问他是用了什么工具怎样做到的，他告诉我是一个空格一个个敲出来的，当时我就当做没看过他代码一样，一个个敲我怎么可能有这个功夫去敲空格。后来碰到代码多的时候是在没办法，写在一坨又费时间又要加冒号引号之类的，可读性有差想想有没有什么办法能做这些重复的工作这是想到了宏就开始进行尝试 先拿部分代码做测试 将代码放入notepad中，notepad有宏思路先将”转换为\” 然后添加外部的html+=” 和结尾的” 首先录制宏将” 替换为\”开启录制 替换 停止 保存宏 保存宏之后以后就可以直接使用 添加html+=” 和” 添加前缀使用宏录制的时候不要用鼠标操作，一切都用键盘 首先先将光标点击宏录制 输入html+=” 输入end按键将光标移到尾部 输入尾部的” 再按Home按键将光标回到开头 在按↓将光标移到下一行 暂停宏保存保存后使用保存成宏之后以后使用直接将代码丢进去执行宏就可以完成操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java poi封装设计思维]]></title>
      <url>%2F2017%2F08%2F04%2Fpro%2Fpoi%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[poi的简单封装与封装思维分享 文章的目的是分享怎样提高使用poi的效率，已经提高代码的可读性、编程性、维护性 通常看到许多程序员使用poi导出execle的时候都是一个方法写下来，几乎没有使用面向对象编程这个优势，这可以能是j2e程序员长期以来开发的思维固定有关，没有使用更多设计模式与面向对象编程。 让我们先看一段传统j2e程序员同事使用poi导出部分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217public static HSSFWorkbook createWB(String fileName,String titleName,List list, String wbName) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, ParseException &#123; HSSFWorkbook wb = new HSSFWorkbook(); HSSFSheet sheet = wb.createSheet(wbName); // 设置表格默认列宽度为1个字节 sheet.setDefaultColumnWidth((short) 1); // 生成一个样式 HSSFCellStyle style = wb.createCellStyle(); // 设置这些样式 style.setFillForegroundColor(HSSFColor.SKY_BLUE.index); style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND); style.setBorderBottom(HSSFCellStyle.BORDER_THIN); style.setBorderLeft(HSSFCellStyle.BORDER_THIN); style.setBorderRight(HSSFCellStyle.BORDER_THIN); style.setBorderTop(HSSFCellStyle.BORDER_THIN); style.setAlignment(HSSFCellStyle.ALIGN_CENTER); // 生成一个字体 HSSFFont font = wb.createFont(); font.setColor(HSSFColor.VIOLET.index); font.setFontHeightInPoints((short) 12); font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); // 把字体应用到当前的样式 style.setFont(font); List&lt;QuestionnaireQuestionBankVO&gt; bankVOList = list; int rownum = 0; HSSFRow row = sheet.createRow(rownum); HSSFCell cell = null; List&lt;QuestionnaireQuestionBankVO&gt; headList = new ArrayList&lt;&gt;(); List&lt;QuestionnaireQuestionBankVO&gt; bodyList = new ArrayList&lt;&gt;(); List&lt;QuestionnaireQuestionBankVO&gt; shootList = new ArrayList&lt;&gt;(); int maxSize =60; for(QuestionnaireQuestionBankVO bankVO : bankVOList)&#123; if(&quot;1&quot;.equals(bankVO.getQuestionClassify()))&#123; bodyList.add(bankVO); &#125;else if(&quot;2&quot;.equals(bankVO.getQuestionClassify()))&#123; headList.add(bankVO); &#125;else if(&quot;3&quot;.equals(bankVO.getQuestionClassify()))&#123; shootList.add(bankVO); &#125; &#125; //标题 for(int i=0;i&lt;maxSize;i++)&#123; cell = row.createCell(i); if(i==0)&#123; cell.setCellValue(titleName); &#125; &#125; sheet.addMergedRegion(new CellRangeAddress(0,0,0,maxSize-1)); //表头 int initHeadNum=0; for(QuestionnaireQuestionBankVO headVO : headList)&#123; if(initHeadNum&lt;2)&#123; if(initHeadNum&lt;1)&#123; row = sheet.createRow(++rownum); &#125; for(int a=initHeadNum*30;a&lt;(initHeadNum+1)*30;a++)&#123; cell = row.createCell(a); if(a==0 || a==30)&#123; String value = headVO.getQuestionTitle();//题目名称 if(!&quot;3&quot;.equals(headVO.getQuestionType()))&#123;//单选多选 List&lt;QuestionnaireQuestionOptionVO&gt; optionList = headVO.getQuestionnaireQuestionOptionVO(); for(QuestionnaireQuestionOptionVO optionVO : optionList)&#123; value+=&quot; □ &quot; + optionVO.getOptionName(); &#125; &#125; cell.setCellValue(value); &#125; &#125; &#125; sheet.addMergedRegion(new CellRangeAddress(rownum,rownum,initHeadNum*30,(initHeadNum+1)*30-1)); initHeadNum++; if(initHeadNum&gt;=2)&#123; initHeadNum=0; &#125; &#125; //题目 for(QuestionnaireQuestionBankVO bodyVO : bodyList)&#123; String questionType = bodyVO.getQuestionType(); String isrequired = bodyVO.getIsRequired(); if(&quot;1&quot;.equals(questionType))&#123; questionType=&quot;单选题&quot;; &#125;else if(&quot;2&quot;.equals(questionType))&#123; questionType=&quot;多选题&quot;; &#125;else if(&quot;3&quot;.equals(questionType))&#123; questionType=&quot;填空题&quot;; &#125; if(&quot;0&quot;.equals(isrequired))&#123; isrequired=&quot;&quot;; &#125;else if(&quot;1&quot;.equals(isrequired))&#123; isrequired=&quot;*&quot;; &#125; if(&quot;3&quot;.equals(bodyVO.getQuestionType()))&#123; row = sheet.createRow(++rownum); for(int i=0;i&lt;60;i++)&#123; cell = row.createCell(i); String value=&quot;&quot;; if(i==0)&#123; value = bodyVO.getQuestionTitle() + &quot; &quot; + isrequired + &quot; &quot; + &quot;【&quot; + questionType + &quot;】&quot;;//题目名称 &#125; cell.setCellValue(value+&quot;\n&quot;); &#125; sheet.addMergedRegion(new CellRangeAddress(rownum,rownum,0,59)); &#125;else&#123; String groupingLayoutPc = bodyVO.getGroupingLayoutPc();//分组布局 String optionLayoutPc = bodyVO.getOptionLayoutPc();//选项布局 List groupName= new ArrayList&lt;&gt;();//分组名称数组 List&lt;QuestionnaireQuestionOptionVO&gt; optionVOList = bodyVO.getQuestionnaireQuestionOptionVO(); for(QuestionnaireQuestionOptionVO optionVO : optionVOList)&#123; Boolean result = true; String groupingName = optionVO.getGroupingName()==null?&quot;&quot;:optionVO.getGroupingName(); for(Object s : groupName)&#123; if(groupingName.equals(s))&#123; result=false; &#125; &#125; if(result)&#123; groupName.add(groupingName); &#125; &#125; row = sheet.createRow(++rownum); String value=&quot;&quot;; value = bodyVO.getQuestionTitle() + &quot; &quot; + isrequired + &quot; &quot; + &quot;【&quot; + questionType + &quot;】&quot;;//题目名称 \&quot;b\nc\&quot; value+=&quot;\n&quot;; if(&quot;1&quot;.equals(groupingLayoutPc))&#123; if(&quot;1&quot;.equals(optionLayoutPc))&#123; if(!&quot;&quot;.equals(groupName.get(0)) &amp;&amp; groupName.get(0)!=&quot;&quot; &amp;&amp; groupName.size()&gt;0)&#123; value += initValue(optionVOList,groupName,1); &#125;else&#123; int num11=0; for(QuestionnaireQuestionOptionVO option11 : optionVOList)&#123; if(num11==0)&#123; value+= &quot; □ &quot; + option11.getOptionName(); num11++; &#125;else&#123; value+=&quot;\n&quot;+ &quot; □ &quot; + option11.getOptionName(); &#125; &#125; &#125; &#125;else if(&quot;2&quot;.equals(optionLayoutPc))&#123; if(!&quot;&quot;.equals(groupName.get(0)) &amp;&amp; groupName.get(0)!=&quot;&quot; &amp;&amp; groupName.size()&gt;0)&#123; value += initValue(optionVOList,groupName,2); &#125;else&#123; int num11=0; for(QuestionnaireQuestionOptionVO option11 : optionVOList)&#123; if(num11==0)&#123; value+= &quot; □ &quot; + option11.getOptionName(); &#125;else&#123; if(num11%2!=0)&#123; value+= &quot; □ &quot; + option11.getOptionName(); &#125;else&#123; value+=&quot;\n&quot;+ &quot; □ &quot; + option11.getOptionName(); &#125; &#125; num11++; &#125; &#125; &#125;else if(&quot;4&quot;.equals(optionLayoutPc))&#123; if(!&quot;&quot;.equals(groupName.get(0)) &amp;&amp; groupName.get(0)!=&quot;&quot; &amp;&amp; groupName.size()&gt;0)&#123; value += initValue(optionVOList,groupName,4); &#125;else&#123; int num11=0; for(QuestionnaireQuestionOptionVO option11 : optionVOList)&#123; if(num11==0)&#123; value+= &quot; □ &quot; + option11.getOptionName(); &#125;else&#123; if(num11%4!=0)&#123; value+= &quot; □ &quot; + option11.getOptionName(); &#125;else&#123; value+=&quot;\n&quot;+ &quot; □ &quot; + option11.getOptionName(); &#125; &#125; num11++; &#125; &#125; &#125; &#125;else if(&quot;2&quot;.equals(groupingLayoutPc))&#123; if(groupName.size()&lt;2)&#123; value += initValue(optionVOList,groupName,Integer.parseInt(optionLayoutPc)); &#125;else&#123; List&lt;List&lt;String&gt;&gt; lists= new ArrayList&lt;List&lt;String&gt;&gt;(); for(Object name : groupName)&#123; List&lt;String&gt; optionList = new ArrayList&lt;String&gt;(); for(QuestionnaireQuestionOptionVO option21 : optionVOList)&#123; if(name.equals(option21.getGroupingName()))&#123; optionList.add(option21.getOptionName()); &#125; &#125; lists.add(optionList); &#125; if(&quot;1&quot;.equals(optionLayoutPc))&#123; value += initValue2(optionVOList,groupName,lists,1); &#125;else if(&quot;2&quot;.equals(optionLayoutPc))&#123; value += initValue2(optionVOList,groupName,lists,2); &#125;else if(&quot;4&quot;.equals(optionLayoutPc))&#123; value += initValue2(optionVOList,groupName,lists,4); &#125; &#125; &#125; for(int i=0;i&lt;60;i++)&#123; cell = row.createCell(i); if(i==0)&#123; cell.setCellValue(value); &#125; &#125; sheet.addMergedRegion(new CellRangeAddress(rownum,rownum,0,59)); &#125; &#125; 封装代码 代码量非常多很多复用的没有复用到，代码可读性差，维护性也差。代码量也相当多再看看加上面向编程 使用代码 主要是ExecleHelper为封装工具使用建造者模式创建execle文件 再导出 12.setTitle(tbWjQuestionnairePO.getQuestionnaireTitle())//为添加固定模板的title 看一下内部代码 BaseEBean父类 以上使用代码封装在一个basebean中做唯一个类封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class BaseEBean &#123; public HSSFWorkbook wb; public HSSFSheet sheet; public int index;//行数指针 public void addIndex() &#123; index++; &#125; /** * 获取当前行 * * @return */ public HSSFRow getHSSFRow() &#123; return sheet.createRow(index); &#125; /** * 获取下一行 * * @return */ public HSSFRow getAddHSSFRow() &#123; addIndex(); return getHSSFRow(); &#125; /** * 合并单元格 * * @param b1r 第一表格个行 * @param b2r 第二表格个行 * @param b1c 第一个表格列 * @param b2c 第二个表格列 */ public void hbTabl(int b1r, int b2r, int b1c, int b2c) &#123; CellRangeAddress range = new CellRangeAddress(b1r, b2r, b1c, b2c); sheet.addMergedRegion(range); &#125; public void setInit(HSSFWorkbook wb, HSSFSheet sheet, int index) &#123; this.wb = wb; this.sheet = sheet; this.index = index; &#125; public HSSFWorkbook build() &#123; return wb; &#125; /** * 添加内容 * * @param row0 * @param y * @param content */ public HSSFCell setContentY(HSSFRow row0, int y, String content) &#123; HSSFCell cell0 = row0.createCell(y); cell0.setCellValue(content); return cell0; &#125; /** * 添加内容 * * @param row0 * @param y * @param content */ public HSSFCell setContentY(HSSFRow row0, int y, String content, HSSFCellStyle style) &#123; HSSFCell cell0 = row0.createCell(y); cell0.setCellValue(content); cell0.setCellStyle(style); return cell0; &#125; /** * 添加合并空行 * @param start * @param end */ public void addKong(int start, int end) &#123; addIndex(); hbTabl(index, index, start, end); &#125;&#125; ExecleHelper 构造类 构造类创建HSSFWorkbook 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ExecleHelper extends BaseEBean &#123; private ExecleHelper execleTopicHelper; public ExecleHelper() &#123; wb = new HSSFWorkbook(); creaTab(&quot;表格1&quot;); &#125; public static ExecleHelper creator() &#123; return new ExecleHelper(); &#125; public HSSFWorkbook build() &#123; return wb; &#125; public void addIndex() &#123; index++; &#125; /** * 创建表 * * @param name * @return */ public ExecleHelper creaTab(String name) &#123; sheet = wb.createSheet(name); return this; &#125; /** * 设置标题 * * @param title * @return */ public ExecleHelper setTitle(String title) &#123; HSSFRow row0 = getHSSFRow(); hbTabl(0, 0, 0, 7); setContentY(row0, 0, title, ExecleStyleHelper.getTitileStyle(wb)); return this; &#125; /** * 设置标题 * * @param title * @return */ public ExecleHelper setTitle(String title, int b1r, int b2r, int b1c, int b2c) &#123; HSSFRow row0 = sheet.createRow(index); hbTabl(b1r, b2r, b1c, b2c); setContentY(row0, 0, title, ExecleStyleHelper.getTitileStyle(wb)); return this; &#125; public &lt;T extends BaseEBean&gt; T addEBean(T baseEInterface) &#123; baseEInterface.setInit(wb, sheet, index); return (T) baseEInterface; &#125;&#125; 使用不同模板 .addEBean(new TopicEBean())在工具类中添加你所需要的bean模板 1234public &lt;T extends BaseEBean&gt; T addEBean(T baseEInterface) &#123; baseEInterface.setInit(wb, sheet, index); return (T) baseEInterface; &#125; 模板 每一个不同execle样式放入不同的EBean对象将逻辑写在EBean对象中代码简洁已读，维护修改性强 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TopicEBean extends BaseEBean &#123; public TopicEBean addData(List&lt;QuestAnalyzeVO&gt; list) &#123; for (QuestAnalyzeVO questAnalyzeVO : list) &#123; addItem(questAnalyzeVO); &#125; return this; &#125; private void addItem(QuestAnalyzeVO questAnalyzeVO) &#123; HSSFRow hssfRow = getAddHSSFRow(); hbTabl(index, index, 0, 3); setContentY(hssfRow, 0, questAnalyzeVO.getQuestionTitle(),ExecleStyleHelper.getBar(wb)); hbTabl(index, index, 4, 5); setContentY(hssfRow, 4, getType(questAnalyzeVO.getQuestionType()),ExecleStyleHelper.getBar(wb)); hbTabl(index, index, 6, 7); setContentY(hssfRow, 6, getIsBt(questAnalyzeVO.getIsRequired()),ExecleStyleHelper.getBar(wb)); HSSFRow hssfRow2 = getAddHSSFRow(); hbTabl(index, index, 0, 3); setContentY(hssfRow2, 0, &quot;标签名：&quot;); hbTabl(index, index, 4, 7); setContentY(hssfRow2, 4, &quot;小计：&quot;); List&lt;QuestAnalyzeItemVO&gt; list = questAnalyzeVO.getItemVOList(); for (QuestAnalyzeItemVO questAnalyzeItemVO : list) &#123; addItemTopic(questAnalyzeItemVO); &#125; addKong(0,7); &#125; private void addItemTopic(QuestAnalyzeItemVO questAnalyzeItemVO) &#123; HSSFRow hssfRow = getAddHSSFRow(); hbTabl(index, index, 0, 3); setContentY(hssfRow, 0, questAnalyzeItemVO.getOptionName()); hbTabl(index, index, 4, 7); setContentY(hssfRow, 4, questAnalyzeItemVO.getFiiNum()); &#125; public String getType(String type) &#123; if (&quot;1&quot;.equals(type)) &#123; return &quot;【单选】&quot;; &#125; if (&quot;2&quot;.equals(type)) return &quot;【多选】&quot;; return &quot;&quot;; &#125; public String getIsBt(String isbt) &#123; String str = isbt == null ? &quot;否&quot; : isbt.equals(&quot;1&quot;) ? &quot;是&quot; : &quot;否&quot;; return &quot;是否必填：&quot; + str; &#125;&#125; 填写样式123456789101112131415161718192021222324252627282930313233343536373839public class ExecleStyleHelper &#123; public static HSSFCellStyle getTitileStyle(HSSFWorkbook workbook) &#123; // 设置字体 HSSFFont headfont = workbook.createFont(); headfont.setFontName(&quot;黑体&quot;); headfont.setFontHeightInPoints((short) 22);// 字体大小 headfont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);// 加粗 // 另一个样式 HSSFCellStyle headstyle = workbook.createCellStyle(); headstyle.setFont(headfont); headstyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);// 左右居中 headstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);// 上下居中 headstyle.setLocked(true); headstyle.setWrapText(true);// 自动换行 return headstyle; &#125; /** * bar * @param workbook * @return */ public static HSSFCellStyle getBar(HSSFWorkbook workbook) &#123; // Sheet样式 HSSFCellStyle sheetStyle = workbook.createCellStyle(); // 背景色的设定// sheetStyle.setFillBackgroundColor(HSSFColor.ROYAL_BLUE.index)// sheetStyle.setBorderBottom(HSSFCellStyle.BORDER_THIN); //下边框// sheetStyle.setBorderLeft(HSSFCellStyle.BORDER_THIN);//左边框// sheetStyle.setBorderTop(HSSFCellStyle.BORDER_THIN);//上边框// sheetStyle.setBorderRight(HSSFCellStyle.BORDER_THIN);//右边框; // 前景色的设定 sheetStyle.setFillForegroundColor(HSSFColor.PALE_BLUE.index); // 填充模式 sheetStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND); return sheetStyle; &#125;&#125; 总结 以上为部分代码设计模式，还有很大的设计空间，需要童鞋们发挥自己的想象里考虑好自己封装设计代码目的是什么。总结一下主要围绕这几点 提高码代码速度减少工作量（偷懒）将大量服用封装成对象。万物皆为对象 提高代码效率 减少重复工作将功能作为模块各做各自功能 提高代码可读性在代码上提高别人对代码的可读性即使没有备注 维护性，当二次开发或者修改某些功能时我只需要把模块的东西替换不需要一行行去看，牵一发而动全身 掌握这几点再复杂的模板都能导出 拓展思维 编程思维最重要比如更提升封装，可以将execle中封装成一个模板我需要获取长宽多少的模板什么背景直接将这些封装起来构造出来通过适配器将数据与模板分离将数据在适配器中填入模板中 导出结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dqdp sql 再次封装]]></title>
      <url>%2F2017%2F07%2F12%2Fpro%2Fdqdp%20Sql%E6%8B%BC%E8%A3%85%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242public class SQLUtil &#123; public static String getCountSQL(String searchSQL) &#123; return &quot;select count(1) from (&quot; + searchSQL.replaceAll(&quot;(?i)\\basc\\b|\\bdesc\\b&quot;, &quot;&quot;).replaceAll(&quot;(?i)order\\s+by\\s+\\S+(\\s*[,\\s*\\S+])*&quot;, &quot;&quot;) + &quot; ) a &quot;; &#125; /** * 拦截搜索内容 * @param object * @return */ public static Object intercept(Object object) &#123; if (object == null) return object; if (object instanceof String) &#123; String str = (String) object; return str.replaceAll(&quot;([&apos;;])+|(--)+&quot;,&quot;&quot;); &#125; return null; &#125; /** * 分页查询 * * @param baseDAO * @param condSQL * @param cls * @param searchValue * @param pager * @return * @throws SQLException */ public static Pager pagetSql(BaseDAOImpl baseDAO, String condSQL, Class cls, Map searchValue, Pager pager) throws SQLException &#123; String countSQL = querySize(condSQL); String searchSQL = condSQL; return baseDAO.pageSearchByField(cls, countSQL, searchSQL, searchValue, pager); &#125; public static String querySize(String sql) throws SQLException &#123; String f = &quot;FROM&quot;; String basesql = &quot;select count(1) FROM &quot;; int index = sql.indexOf(f); String akk = basesql + sql.substring(index + f.length(), sql.length()); return akk; &#125; public static class ABean &#123; public String A; public String B = &quot;bbb&quot;; public ABean(String A) &#123; this.A = A; &#125; &#125; public static void main(String[] arg) throws IllegalAccessException &#123; String sql = AddSearch.create(&quot;insert &quot;).insert(new ABean(&quot;aa&quot;), &quot;A&quot;, &quot;B&quot;).build(); System.out.println(sql); &#125; public static class AddSearch &#123; Map&lt;String, Object&gt; map; String sql; private int type; public String build() &#123; return sql; &#125; public AddSearch(Map&lt;String, Object&gt; map, String sql) &#123; this.map = map; this.sql = sql; this.type = 0; &#125; public AddSearch(String sql) &#123; this.sql = sql; this.type = 1; &#125; public static AddSearch create(Map&lt;String, Object&gt; map, String sql) &#123; return new AddSearch(map, sql); &#125; public static AddSearch create(String sql) &#123; return new AddSearch(sql); &#125; public AddSearch deleteList(String key, List&lt;String&gt; ids) &#123; sql += &quot; ( &quot;; for (String str : ids) &#123; String itemSql = &quot; &quot;; itemSql += key + &quot; = &apos;&quot; + intercept(str) + &quot;&apos; or&quot;; sql += itemSql; &#125; sql = VerifyUtil.endClearOr(sql); sql += &quot; ) &quot;; return this; &#125; /** * 批量插入 * * @param list * @param &lt;T&gt; * @return * @throws IllegalAccessException */ public &lt;T&gt; AddSearch insertList(List&lt;T&gt; list, String... keys) throws IllegalAccessException &#123; sql += &quot; values &quot;; for (T item : list) &#123; sql += &quot; ( &quot;; Class userCla = (Class) item.getClass(); Field[] fs = userCla.getDeclaredFields(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (Field f : fs) &#123; f.setAccessible(true); Object val = f.get(item); map.put(f.getName(), val); &#125; String itemSql = &quot;&quot;; for (String key : keys) &#123; String val = map.get(key) == null ? null : &quot;&apos;&quot; + intercept(map.get(key)) + &quot;&apos;&quot;; itemSql += val + &quot;,&quot;; &#125; itemSql = VerifyUtil.endClear(itemSql); sql += itemSql; sql += &quot; ),&quot;; &#125; sql = VerifyUtil.endClear(sql); return this; &#125; /** * 插入数据 * * @return * @throws IllegalAccessException */ public &lt;T&gt; AddSearch insert(T t, String... keys) throws IllegalAccessException &#123; sql += &quot; values ( &quot;; Class userCla = (Class) t.getClass(); Field[] fs = userCla.getDeclaredFields(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (Field f : fs) &#123; f.setAccessible(true); Object val = f.get(t); map.put(f.getName(), val); &#125; String itemSql = &quot;&quot;; for (String key : keys) &#123; String val = map.get(key) == null ? null : &quot;&apos;&quot; + intercept(map.get(key)) + &quot;&apos;&quot;; itemSql += val + &quot;,&quot;; &#125; itemSql = VerifyUtil.endClear(itemSql); sql += itemSql; sql += &quot; )&quot;; return this; &#125; /** * @param sqlName 条件 * @param mapKey * @return */ public AddSearch add(String sqlName, String mapKey) &#123; if (type == 0) &#123; addMap(sqlName, mapKey); &#125; else &#123; addValue(sqlName, mapKey); &#125; return this; &#125; /** * @param sqlName * @param mapKey * @return */ public AddSearch addLike(String sqlName, String mapKey) &#123; if (type == 0) &#123; addLikeMap(sqlName, mapKey); &#125; else &#123; addLikeValue(sqlName, mapKey); &#125; return this; &#125; /** * 查询in方法 * * @param sqlName * @param values * @return */ public AddSearch in(String sqlName, List&lt;String&gt; values) &#123; String inSql = &quot;&quot;; for (String str : values) &#123; if (!VerifyUtil.isEmpty(str)) &#123; inSql += &quot;&apos;&quot; + intercept(str) + &quot;&apos;,&quot;; &#125; &#125; inSql = VerifyUtil.endClear(inSql); sql += &quot; and &quot; + sqlName + &quot; in ( &quot; + inSql + &quot; ) &quot;; return this; &#125; /** * map中赋值 * * @param sqlName * @param mapKey */ private void addMap(String sqlName, String mapKey) &#123; if (!VerifyUtil.isEmpty(map.get(mapKey))) sql += &quot; and &quot; + sqlName + &quot; = &apos;&quot; + intercept(map.get(mapKey)) + &quot;&apos;&quot;; &#125; private void addLikeMap(String sqlName, String mapKey) &#123; if (!VerifyUtil.isEmpty(map.get(mapKey))) sql += &quot; and &quot; + sqlName + &quot; like &apos;%&quot; + intercept(map.get(mapKey)) + &quot;%&apos;&quot;; &#125; /** * value直接赋值 * * @param sqlName * @param mapKey */ private void addValue(String sqlName, String mapKey) &#123; if (!VerifyUtil.isEmpty(mapKey)) sql += &quot; and &quot; + sqlName + &quot; = &apos;&quot; + intercept(mapKey) + &quot;&apos;&quot;; &#125; private void addLikeValue(String sqlName, String mapKey) &#123; if (!VerifyUtil.isEmpty(mapKey)) sql += &quot; and &quot; + sqlName + &quot; like &apos;%&quot; + intercept(mapKey) + &quot;%&apos;&quot;; &#125; &#125;&#125; 批量插入vo对象1234567891011121314@Override public void insertAnswerTopic(List&lt;AnswerDetailVO&gt; answerDetailVO) throws Exception, BaseException &#123; if (answerDetailVO.size() &lt; 1) return; String[] keys = &#123;&quot;answerDetailId&quot;, &quot;answerId&quot;, &quot;questionnaireQuestionId&quot;, &quot;questionClassify&quot;, &quot;questionnaireLabelId&quot;, &quot;inputContent&quot;&#125;; String sql = &quot;INSERT INTO tb_wj_answer_detail&quot; + &quot; (`answer_detail_id`, `answer_id`, `questionnaire_question_id`,&quot; + &quot; `question_classify`, `questionnaire_label_id`, `label_name`, &quot; + &quot;`questionnaire_option_id`, `option_name`, `input_content`)&quot;; sql = SQLUtil.AddSearch.create(sql).insertList(answerDetailVO, keys).build(); super.preparedSql(sql); super.executeUpdate(); &#125; keys 则是对象的属性，是通过反射获取需要插入对象内属性，再进行插入.注意顺序与语句sql一致 分页查询1234567@Override public Pager searchAreaTemplateStatus(Map searchValue, Pager pager) throws Exception,SQLException &#123; String sql =&quot;SELECT t.* FROM tb_wj_area_template t where 1=1 &quot;; sql= SQLUtil.AddSearch.create(searchValue,sql) .add(&quot;t.questionnaire_type&quot;,&quot;type&quot;).build(); return SQLUtil.pagetSql(this,sql, AreaTemplateVO.class,searchValue,pager); &#125; 分页查询在dqdp封装中的 pager内进行再次封装如使用basetable 2.0 翻页方法 在SQLUtil 中添加一个pagetSql对应的basetable即可add 则添加查询语句addLike 为模糊搜索如传入map add和addLike 第二个值传入map对象的key值如没有传map add和addlike 第二个值则传入sql该字段的值 多条数据查询批量查询12345678910@Override public List&lt;TemplateQuestionBankVO&gt; findTopicByTemplateQuestionIds(List&lt;String&gt; qustIds) throws Exception,SQLException&#123; if(qustIds.size()&lt;1) return new ArrayList&lt;&gt;(); String sql =&quot;SELECT t.* from tb_wj_template_question_bank t where 1=1 &quot;; sql= SQLUtil.AddSearch.create(sql) .in(&quot;t.template_question_id&quot;,qustIds) .build(); return super.getList(sql,TemplateQuestionBankVO.class); &#125; 多条数据删除12345678910@Override public void deleteTemplateList(List&lt;String&gt; ids) throws Exception, SQLException &#123; if(ids.size()&lt;1) return; String sql =&quot;DELETE FROM tb_wj_template_question_bank WHERE &quot;; sql =SQLUtil.AddSearch.create(sql).deleteList(&quot;template_question_id&quot;,ids).build(); System.out.println(sql); super.preparedSql(sql); super.executeUpdate(); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 二维码生成工具]]></title>
      <url>%2F2017%2F07%2F10%2Fpro%2Fjava%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%2F</url>
      <content type="text"><![CDATA[java二维码生成需要使用到的jar包：QRCode.jar 下边是一个链接如果链接失效请百度下载。这里提供一个下载：点此下载QRCode.jar 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package cn.com.do1.component.util;import com.swetake.util.Qrcode;import jp.sourceforge.qrcode.QRCodeDecoder;import jp.sourceforge.qrcode.exception.DecodingFailedException;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.HashMap;/** * Created by Administrator on 2017/7/10 0010. */public class TwoDimensionCode &#123; /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 */ public void encoderQRCode(String content, String imgPath) &#123; this.encoderQRCode(content, imgPath, &quot;png&quot;, 7); &#125; /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param output 输出流 */ public void encoderQRCode(String content, OutputStream output) &#123; this.encoderQRCode(content, output, &quot;png&quot;, 7); &#125; /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 * @param imgType 图片类型 */ public void encoderQRCode(String content, String imgPath, String imgType) &#123; this.encoderQRCode(content, imgPath, imgType, 7); &#125; /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param output 输出流 * @param imgType 图片类型 */ public void encoderQRCode(String content, OutputStream output, String imgType) &#123; this.encoderQRCode(content, output, imgType, 7); &#125; /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param imgPath 图片路径 * @param imgType 图片类型 * @param size 二维码尺寸 */ public void encoderQRCode(String content, String imgPath, String imgType, int size) &#123; try &#123; BufferedImage bufImg =this.qRCodeCommon(content, imgType, size); File imgFile = new File(imgPath); // 生成二维码QRCode图片 ImageIO. write(bufImg, imgType , imgFile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 生成二维码(QRCode)图片 * @param content 存储内容 * @param output 输出流 * @param imgType 图片类型 * @param size 二维码尺寸 */ public void encoderQRCode(String content, OutputStream output, String imgType, int size) &#123; try &#123; BufferedImage bufImg =this.qRCodeCommon(content, imgType, size); // 生成二维码QRCode图片 ImageIO.write(bufImg, imgType, output); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 生成二维码(QRCode)图片的公共方法 * @param content 存储内容 * @param imgType 图片类型 * @param size 二维码尺寸 * @return */ private BufferedImage qRCodeCommon(String content, String imgType, int size) &#123; BufferedImage bufImg = null; try &#123; Qrcode qrcodeHandler = new Qrcode(); // 设置二维码排错率，可选L(7%)、M(15%)、Q(25%)、H(30%)，排错率越高可存储的信息越少，但对二维码清晰度的要求越小 qrcodeHandler.setQrcodeErrorCorrect( &apos;M&apos;); qrcodeHandler.setQrcodeEncodeMode( &apos;B&apos;); // 设置设置二维码尺寸，取值范围1-40，值越大尺寸越大，可存储的信息越大 qrcodeHandler.setQrcodeVersion(size); // 获得内容的字节数组，设置编码格式 byte[] contentBytes = content.getBytes( &quot;utf-8&quot;); // 图片尺寸 int imgSize = 67 + 12 * (size - 1); bufImg = new BufferedImage(imgSize, imgSize, BufferedImage.TYPE_INT_RGB ); Graphics2D gs = bufImg.createGraphics(); // 设置背景颜色 gs.setBackground(Color. WHITE); gs.clearRect(0, 0, imgSize, imgSize); // 设定图像颜色&gt; BLACK gs.setColor(Color. BLACK); // 设置偏移量，不设置可能导致解析出错 int pixoff = 2; // 输出内容&gt; 二维码 if (contentBytes. length &gt; 0 &amp;&amp; contentBytes.length &lt; 800) &#123; boolean[][] codeOut = qrcodeHandler.calQrcode(contentBytes); for ( int i = 0; i &lt; codeOut. length; i++) &#123; for ( int j = 0; j &lt; codeOut. length; j++) &#123; if (codeOut[j][i]) &#123; gs.fillRect(j * 3 + pixoff, i * 3 + pixoff, 3, 3); &#125; &#125; &#125; &#125; else &#123; throw new Exception( &quot;QRCode content bytes length = &quot; + contentBytes. length + &quot; not in [0, 800].&quot;); &#125; gs.dispose(); bufImg.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bufImg; &#125; /** * 解析二维码（QRCode） * @param imgPath 图片路径 * @return */ public String decoderQRCode(String imgPath) &#123; // QRCode 二维码图片的文件 File imageFile = new File(imgPath); BufferedImage bufImg = null; String content = null; try &#123; bufImg = ImageIO.read(imageFile); QRCodeDecoder decoder = new QRCodeDecoder(); content = new String(decoder.decode(new TwoDimensionCodeImage(bufImg)), &quot;utf-8&quot; ); &#125; catch (IOException e) &#123; System. out.println( &quot;Error: &quot; + e.getMessage()); e.printStackTrace(); &#125; catch (DecodingFailedException dfe) &#123; System. out.println( &quot;Error: &quot; + dfe.getMessage()); dfe.printStackTrace(); &#125; return content; &#125; /** * 解析二维码（QRCode） * @param input 输入流 * @return */ public String decoderQRCode(InputStream input) &#123; BufferedImage bufImg = null; String content = null; try &#123; bufImg = ImageIO. read(input); QRCodeDecoder decoder = new QRCodeDecoder(); content = new String(decoder.decode( new TwoDimensionCodeImage(bufImg)), &quot;utf-8&quot; ); &#125; catch (IOException e) &#123; System. out.println( &quot;Error: &quot; + e.getMessage()); e.printStackTrace(); &#125; catch (DecodingFailedException dfe) &#123; System. out.println( &quot;Error: &quot; + dfe.getMessage()); dfe.printStackTrace(); &#125; return content; &#125; public static void main(String[] args) &#123; String imgPath = &quot;F:/UpFile/iamge.png&quot;; HashMap&lt;String,Object&gt; map =new HashMap&lt;&gt;(); map.put(&quot;id&quot;,&quot;1&quot;); map.put(&quot;name&quot;,&quot;名称&quot;); map.put(&quot;phone&quot;,&quot;110&quot;); String encoderContent = VerifyUtil.toJson(map); TwoDimensionCode handler = new TwoDimensionCode(); handler.encoderQRCode(encoderContent, imgPath, &quot;png&quot; ); System. out.println( &quot;========encoder success&quot; ); String decoderContent = handler.decoderQRCode(imgPath); System. out.println( &quot;解析结果如下：&quot; ); System. out.println(decoderContent); System. out.println( &quot;========decoder success!!!&quot; ); &#125;&#125; 1234567891011121314151617181920212223242526272829package cn.com.do1.component.util;import jp.sourceforge.qrcode.data.QRCodeImage;import java.awt.image.BufferedImage;/** * Created by Administrator on 2017/7/10 0010. */public class TwoDimensionCodeImage implements QRCodeImage &#123; BufferedImage bufImg; public TwoDimensionCodeImage(BufferedImage bufImg) &#123; this.bufImg = bufImg; &#125; public int getHeight() &#123; return bufImg.getHeight(); &#125; public int getPixel(int x, int y) &#123; return bufImg.getRGB(x, y); &#125; public int getWidth() &#123; return bufImg.getWidth(); &#125;&#125; 配合文件下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.com.do1.component.wjxt.questionManage.ui;import cn.com.do1.component.baseweb.ui.MyBaseAction;import cn.com.do1.component.util.ConfigPath;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletResponse;import java.io.*;/** * Created by Administrator on 2017/7/10 0010. */public class FilesAction extends MyBaseAction &#123; @ResponseBody @RequestMapping(&quot;downLoad&quot;) public HttpServletResponse download(HttpServletResponse response, String fileName) throws UnsupportedEncodingException &#123; System.out.println(&quot;fileName:&quot;+fileName); String bname = new String(fileName.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;); System.out.println(&quot;bname：&quot;+bname); try &#123; String savePath = ConfigPath.getInstance().getString(&quot;savaPath&quot;); String path = savePath+&quot;/&quot;+bname; try &#123; // path是指欲下载的文件的路径。 File file = new File(path); // 取得文件名。 String filename = file.getName(); // 取得文件的后缀名。 String ext = filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1).toUpperCase(); // 以流的形式下载文件。 InputStream fis = new BufferedInputStream(new FileInputStream(path)); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); // 设置response的Header response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(filename.getBytes())); response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length()); response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); response.setContentType(&quot;application/octet-stream&quot;); toClient.write(buffer); toClient.flush(); toClient.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return response; &#125; catch (Exception e) &#123; log.error(&quot;下载失败：-&quot; + e.getMessage(), e); return response; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android im 简易快速集成使用]]></title>
      <url>%2F2017%2F06%2F30%2Fpro%2Fandroid%E9%9B%86%E6%88%90%E7%8E%AF%E4%BF%A1%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[android环信快速集成指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux 配置jdk 和tomcat]]></title>
      <url>%2F2017%2F06%2F15%2Fpro%2Flinux%E9%85%8D%E7%BD%AEjdk%E5%92%8Ctomcat%2F</url>
      <content type="text"><![CDATA[一.下载安装对应的jdk,并配置Java环境。官网下载地址： http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u26-download-400750.html 1.将jdk移至/usr/local目录下解压jdk tar -zxvf jdk-6u5-linux-x64.tar.gz 下载将jdk加压后放到/usr/local目录下： [root@master ~]#chmod 755 jdk-6u5-linux-x64.bin [root@master ~]# ./jdk-6u5-linux-x64.bin [root@master ~]#mv jdk1.6.0_05 /usr/local 建立/usr/local/下的jdk软连接方便以后版本升级 ： [root@master ~]# ln -s /usr/local/jdk1.6.0_05/ /usr/local/jdk 2.配置jdk环境变量在 /etc/profile 中加入以下内容： 123456789JAVA_HOME=/usr/local/jdk1.6.0_05JAVA_BIN=/usr/local/jdk1.6.0_05/binPATH=$PATH:$JAVA_BINCLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATH 保存退出 [root@master ~]source /etc/profile 查看java环境变量是否生效 [root@master ~]# java -version123456Java version &quot;1.6.0_05&quot;Java(TM) SE Runtime Environment (build 1.6.0_05-b13)java HotSpot(TM) 64-Bit Server VM (build 10.0-b19, mixed mode) 测试成功 二．下载安装tomcat http://tomcat.apache.org[root@master ~]# unzip apache-tomcat-6.0.30.zip [root@master ~]# mv apache-tomcat-6.0.30/ /usr/local/ [root@master ~]cd /usr/local/ [root@master local]# ln -s /usr/local/apache-tomcat-6.0.30/ /usr/local/tomcat [root@master local]# cd tomcat/bin/ [root@master bin]#ls [root@master bin]#vim catalina.sh 添加以下内容： CATALINA_HOME=/usr/local/apache-tomcat-6.0.30/ [root@master local]#chmod +x *.sh 三．启动tomcat服务器[root@master tomcat]# /usr/local/tomcat /bin/catalina.sh start 四．在浏览器中输入http://localhost:8080/（如果不是本机，则输入对应的ip地址） 测试出现tomcat页面则测试成功 ps：需要说明的是tomcat的默认测试页面是放在webapps下面，这个其实是在server.xml文件中配置的，如下所示：123&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; 注意点Connector 节点设置中文URIEncoding=”UTF-8”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[datatables 简易封装]]></title>
      <url>%2F2017%2F05%2F29%2Fpro%2Fdatatables%E7%AE%80%E6%98%93%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[什么是datatables？ Datatables是一款jquery表格插件。它是一个高度灵活的工具，可以将任何HTML表格添加高级的交互功能。 详细介绍请进入官方网站查询 datatables中文官网 此篇文章主要介绍的是后台的用法已经简易的封装方法 让我们先看一下前端js是怎么实现的，下面是一个真实使用接口 后台框架则使用的是struts+spring+jdbc 的企微dqdp框架 网络请求实例用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var table; function upSerach() &#123; if (table == null) &#123; initTab(); //初始化方法 &#125; else &#123; table.ajax.reload(); &#125; &#125; function initTab() &#123; table = $(&apos;#example&apos;) .DataTable( &#123; language : &#123; &quot;sProcessing&quot; : &quot;处理中...&quot;, &quot;sLengthMenu&quot; : &quot;显示 _MENU_ 项结果&quot;, &quot;sZeroRecords&quot; : &quot;没有匹配结果&quot;, &quot;sInfo&quot; : &quot;显示第 _START_ 至 _END_ 项结果，共 _TOTAL_ 项&quot;, &quot;sInfoEmpty&quot; : &quot;显示第 0 至 0 项结果，共 0 项&quot;, &quot;sInfoFiltered&quot; : &quot;(由 _MAX_ 项结果过滤)&quot;, &quot;sInfoPostFix&quot; : &quot;&quot;, &quot;sSearch&quot; : &quot;搜索:&quot;, &quot;sUrl&quot; : &quot;&quot;, &quot;sEmptyTable&quot; : &quot;表中数据为空&quot;, &quot;sLoadingRecords&quot; : &quot;载入中...&quot;, &quot;sInfoThousands&quot; : &quot;,&quot;, &quot;oPaginate&quot; : &#123; &quot;sFirst&quot; : &quot;首页&quot;, &quot;sPrevious&quot; : &quot;上页&quot;, &quot;sNext&quot; : &quot;下页&quot;, &quot;sLast&quot; : &quot;末页&quot; &#125;, &quot;oAria&quot; : &#123; &quot;sSortAscending&quot; : &quot;: 以升序排列此列&quot;, &quot;sSortDescending&quot; : &quot;: 以降序排列此列&quot; &#125; &#125;, &quot;paging&quot; : true, &quot;lengthChange&quot; : false, &quot;searching&quot; : false, &quot;ordering&quot; : false, &quot;processing&quot; : true, &quot;serverSide&quot; : true, &quot;ajax&quot; : &#123; &quot;url&quot; : &quot;$&#123;basePath&#125;databank/databankAction!findParamList.action&quot;, &quot;type&quot; : &quot;post&quot;, &quot;dataSrc&quot; : function(json) &#123; return json.data; &#125;, &quot;data&quot; : function(d) &#123; d.type=&apos;7&apos;; &#125; &#125;, &quot;columns&quot; : [&#123; &quot;data&quot; : &quot;paramName&quot; &#125;, &#123; &quot;data&quot; : &quot;updateTime&quot; &#125;, &#123; &quot;data&quot; : &quot;paramId&quot; &#125;], &quot;columnDefs&quot; : [&#123; // 定义操作列,######以下是重点######## &quot;targets&quot; : 2,//操作按钮目标列 &quot;data&quot; : null, &quot;render&quot; : function(data, type, row) &#123; var id = row.paramId; var name = row.paramName; var status = &apos;&apos;; return &quot;&lt;div id=\&quot;&quot;+id+&quot;\&quot; status=\&quot;&quot;+status+&quot;\&quot; name=\&quot;&quot;+name+&quot;\&quot; class=\&quot;ctol_list\&quot;&gt;&lt;/div&gt;&quot;; &#125; &#125;] &#125;);&#125; 使用本地数据方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//shuxin liebiao function upSerach() &#123; if (table == null) &#123; initTab(); &#125; else &#123; table.clear(); table.rows.add(datawe).draw(); &#125; &#125; var datawe = [ ]; var table; function initTab() &#123; table = $(&apos;#example&apos;) .DataTable( &#123; language : &#123; &quot;sProcessing&quot; : &quot;处理中...&quot;, &quot;sLengthMenu&quot; : &quot;显示 _MENU_ 项结果&quot;, &quot;sZeroRecords&quot; : &quot;没有匹配结果&quot;, &quot;sInfo&quot; : &quot;显示第 _START_ 至 _END_ 项结果，共 _TOTAL_ 项&quot;, &quot;sInfoEmpty&quot; : &quot;显示第 0 至 0 项结果，共 0 项&quot;, &quot;sInfoFiltered&quot; : &quot;(由 _MAX_ 项结果过滤)&quot;, &quot;sInfoPostFix&quot; : &quot;&quot;, &quot;sSearch&quot; : &quot;搜索:&quot;, &quot;sUrl&quot; : &quot;&quot;, &quot;sEmptyTable&quot; : &quot;表中数据为空&quot;, &quot;sLoadingRecords&quot; : &quot;载入中...&quot;, &quot;sInfoThousands&quot; : &quot;,&quot;, &quot;oPaginate&quot; : &#123; &quot;sFirst&quot; : &quot;首页&quot;, &quot;sPrevious&quot; : &quot;上页&quot;, &quot;sNext&quot; : &quot;下页&quot;, &quot;sLast&quot; : &quot;末页&quot; &#125;, &quot;oAria&quot; : &#123; &quot;sSortAscending&quot; : &quot;: 以升序排列此列&quot;, &quot;sSortDescending&quot; : &quot;: 以降序排列此列&quot; &#125; &#125;, &quot;paging&quot; : true, &quot;lengthChange&quot; : false, &quot;searching&quot; : false, &quot;ordering&quot; : false, &quot;processing&quot; : true, &quot;data&quot; :datawe, &quot;columns&quot; : [&#123; &quot;data&quot; : &quot;id&quot; &#125;, &#123; &quot;data&quot; : &quot;name&quot; &#125;, &#123; &quot;data&quot; : &quot;shelvsStatus&quot; &#125;], &quot;columnDefs&quot; : [&#123; // 定义操作列,######以下是重点######## &quot;targets&quot; : 2,//操作按钮目标列 &quot;data&quot; : null, &quot;render&quot; : function(data, type, row,meta) &#123; var shelvsStatus = row.shelvsStatus; return (shelvsStatus==&apos;1&apos;)?&quot;待上架&quot;:(shelvsStatus==&apos;2&apos;)?&quot;已上架&quot;:(shelvsStatus==&apos;3&apos;)?&quot;下架&quot;:&quot;&quot;; &#125; &#125;] &#125;); &#125; 后台实现源码 首先看一下action 实现 123456789101112131415/** 获取参数列表 * * @throws Exception */@JSONOut(catchException = @CatchException(errCode = &quot;1005&quot;, successMsg = &quot;操作成功&quot;, faileMsg = &quot;操作失败&quot;))public void findParamList() throws Exception &#123; JqDataTable jqd = new JqDataTable(); try &#123; Map&lt;String, Object&gt; map = jqd.getSearch(&quot;type&quot;,&quot;is_photoType&quot;); jqd = iParamDataService.findParamList(jqd, map); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; JqDataTable.doOutList(jqd);&#125; 主要的功能封装在JqDataTable 这个对象类，接下来我们来看看这个对象内的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package aizhuwu.common.bean;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import aizhuwu.common.utils.VerifyUtil;public class JqDataTable &#123; private int draw; private int start; private int length; private int end; private int recordsTotal; private int recordsFiltered; private List&lt;?&gt; data; public JqDataTable() &#123; HttpServletRequest request = ServletActionContext.getRequest(); try &#123; draw = Integer.parseInt(request.getParameter(&quot;draw&quot;)); start = Integer.parseInt(request.getParameter(&quot;start&quot;)); length = Integer.parseInt(request.getParameter(&quot;length&quot;)); end = start + length; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public HashMap&lt;String, Object&gt; getSearch(String... strings) &#123; HttpServletRequest request = ServletActionContext.getRequest(); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (String key : strings) &#123; String param = request.getParameter(key); if (!VerifyUtil.isEmpty(param)) &#123; map.put(key, param); &#125; &#125; return map; &#125; public JqDataTable(int draw, int recordsTotal, int recordsFiltered, List&lt;?&gt; data) &#123; this.draw = draw; this.recordsTotal = recordsTotal; this.recordsFiltered = recordsFiltered; this.data = data; &#125; public void set(int recordsTotal, int recordsFiltered, List&lt;?&gt; data) &#123; this.recordsTotal = recordsTotal; this.recordsFiltered = recordsFiltered; this.data = data; &#125; public int getDraw() &#123; return draw; &#125; public void setDraw(int draw) &#123; this.draw = draw; &#125; public int getRecordsTotal() &#123; return recordsTotal; &#125; public void setRecordsTotal(int recordsTotal) &#123; this.recordsTotal = recordsTotal; &#125; public int getRecordsFiltered() &#123; return recordsFiltered; &#125; public void setRecordsFiltered(int recordsFiltered) &#123; this.recordsFiltered = recordsFiltered; &#125; public List&lt;?&gt; getData() &#123; return data; &#125; public void setData(List&lt;?&gt; data) &#123; this.data = data; &#125; public int getStart() &#123; return start + 1; &#125; public int getLength() &#123; return length; &#125; public void setStart(int start) &#123; this.start = start; &#125; public void setLength(int length) &#123; this.length = length; &#125; public int getEnd() &#123; return end; &#125; public void setEnd(int end) &#123; this.end = end; &#125; public static void doOutList(String json) throws IOException &#123; HttpServletResponse response = ServletActionContext.getResponse(); /* * HttpServletResponse则会返回一个用默认的编码(既ISO-8859-1)编码的PrintWriter实例。这样就会 * 造成中文乱码。而且设置编码时必须在调用getWriter之前设置,不然是无效的。 */ response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.println(json); out.flush(); out.close(); &#125; public static void doOutList(Object obj) throws IOException &#123; Gson g = new GsonBuilder().serializeNulls().setDateFormat(&quot;yyyy-MM-dd HH:mm&quot;).create(); doOutList(g.toJson(obj)); &#125; public static void doOutObject(Object obj) throws IOException &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, &quot;0&quot;); map.put(&quot;desc&quot;, &quot;操作成功&quot;); map.put(&quot;data&quot;, obj); Gson g = new GsonBuilder().serializeNulls().setDateFormat(&quot;yyyy-MM-dd HH:mm&quot;).create(); doOutList(g.toJson(map)); &#125; public static void doOutObject(Object obj, String format) throws IOException &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, &quot;0&quot;); map.put(&quot;desc&quot;, &quot;操作成功&quot;); map.put(&quot;data&quot;, obj); Gson g = new GsonBuilder().serializeNulls().setDateFormat(format).create(); doOutList(g.toJson(map)); &#125; /** * * @param obj * @param str * @throws IOException */ public static void doOutObjectTime(Object obj, String str) throws IOException &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, &quot;0&quot;); map.put(&quot;desc&quot;, &quot;操作成功&quot;); map.put(&quot;data&quot;, obj); Gson g = new GsonBuilder().serializeNulls().setDateFormat(str).create(); doOutList(g.toJson(map)); &#125;&#125; 1.draw 2.start 3.length 这三个参数则是datatables控件封装传输上来的字段，所以在前端是看不大这些字段的传输，可以通过谷歌浏览器开发模式查看有哪些字段上传，我们这套封装主要是试用这三个字段 service 实现则没有做特殊逻辑处理 12345@Override public JqDataTable findParamList(JqDataTable jqd, Map&lt;String, Object&gt; map) throws Exception &#123; // TODO Auto-generated method stub return iParamDataDAO.findParamList(jqd, map); &#125; 犹豫框架是jdbc所有都是拼接sql来实现查询 1234567891011@Overridepublic JqDataTable findParamList(JqDataTable jqd, Map&lt;String, Object&gt; map) throws SQLException &#123; String type=(String) map.get(&quot;type&quot;); String is_photoType = (String) map.get(&quot;is_photoType&quot;); String sqlCity =VerifyUtil.isEmpty(type)?&quot;&quot;:&quot; and a.TYPE = &apos;&quot;+type+&quot;&apos;&quot;; String sqlIsPhotoType =VerifyUtil.isEmpty(is_photoType)?&quot;&quot;:&quot; and a.IS_PHOTO_TYPE = &apos;&quot;+is_photoType+&quot;&apos;&quot;; String sql =&quot;select * FROM TB_PARAM_PARAM_DATA a where 1=1 &quot;+sqlCity+sqlIsPhotoType+&quot; ORDER BY a.UPDATE_TIME DESC&quot;; jqd = AISQLUtils.queryJqData(this, sql, jqd, ParamDataBean.class); return jqd;&#125; 最重要的是jqd = AISQLUtils.queryJqData(this, sql, jqd, ParamDataBean.class);this则为查询方法父类 sql为条件语句 jqd 为翻页对象 ParamDataBean po 对象查询语句FROM 必须大写，封装AISQLUtils 根据FROM第一字段来做分页语句拼接处理 AISQLUtils对应封装Oracle 分页查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package aizhuwu.webservicesys.utils;import java.sql.SQLException;import java.util.HashMap;import java.util.List;import org.apache.poi.ss.formula.functions.T;import aizhuwu.common.bean.JqDataTable;import cn.com.do1.common.framebase.dqdp.BaseDAOImpl;import cn.com.do1.component.backmanager.orgmgr.model.TbDqdpOrganizationPO;public class AISQLUtils &#123; public static List&lt;?&gt; getListPage(BaseDAOImpl base, String sql, JqDataTable jq, Class&lt;?&gt; cls) throws SQLException &#123; String baseSql = &quot;SELECT * FROM ( SELECT A.*,rownum RN FROM &quot; + &quot;(&quot; + sql + &quot;) A ) &quot; + &quot; WHERE RN BETWEEN &apos;&quot; + jq.getStart() + &quot;&apos; AND &apos;&quot; + jq.getEnd() + &quot;&apos; &quot;; base.preparedSql(baseSql); return base.getList(cls); &#125; public static int querySize(BaseDAOImpl base, String sql, JqDataTable jq) throws SQLException &#123; String f = &quot;FROM&quot;; String basesql = &quot;SELECT count(*) FROM &quot;; int index =sql.indexOf(f); String akk = basesql + sql.substring(index+f.length(), sql.length()); return base.executeCount(akk); &#125; /** * 查询分页 * * @param base * @param sql * @param jq * @param cls * @return * @throws SQLException */ public static JqDataTable queryJqData(BaseDAOImpl base, String sql, JqDataTable jq, Class&lt;?&gt; cls) throws SQLException &#123; List&lt;?&gt; list = getListPage(base, sql, jq, cls); int size = querySize(base, sql, jq); jq.set(size, size, list); return jq; &#125;&#125; 总结：框架方法很多种思想是精髓 好的封装方法可大大提高开发效率。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajaxFileUpload文件上传]]></title>
      <url>%2F2017%2F05%2F24%2Fpro%2Fjava%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[文件上传流程：前端-&gt;项目后台-&gt;文件项目-&gt;文件项目写入服务硬盘 上传项目采用的是struts+spring+jdbc 的企微dqdp框架文件服务器接收项目则采用的是springmvc+sping+mybatis前段主要使用的是ajaxFileUpload 插件 前端文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//判断文件类型 function isImage(filePathName)&#123; if(filePathName==&apos;&apos;)&#123; return false; &#125; if(filePathName.indexOf(&quot;.png&quot;)&gt;0)&#123; return true; &#125; if(filePathName.indexOf(&quot;.jpg&quot;)&gt;0)&#123; return true; &#125; if(filePathName.indexOf(&quot;.PNG&quot;)&gt;0)&#123; return true; &#125; if(filePathName.indexOf(&quot;.JPG&quot;)&gt;0)&#123; return true; &#125; return false; &#125;&lt;input type=&quot;file&quot; name=&quot;upload&quot; id=&quot;uploadInput&quot; onchange=&quot;uploadLogo(this)&quot; value=&quot;&quot; class=&quot;fileIpt&quot; /&gt;//文件上传js targert input filefunction uploadLogo(target) &#123; var filePathName = $(&quot;#uploadInput&quot;).val(); console.log(filePathName); if(!isImage(filePathName)) &#123; alert(&quot;请选择要上传的图片文件&quot;); return; &#125; //控制图片上传大小不超过5M var isIE = /msie/i.test(navigator.userAgent) &amp;&amp; !window.opera; var fileSize = 0; if (isIE &amp;&amp; !target.files) &#123; var filePath = target.value; var fileSystem = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;); var file = fileSystem.GetFile (filePath); fileSize = file.Size; &#125; else &#123; fileSize = target.files[0].size; &#125; var size = fileSize / 1024; if(size&gt;5000)&#123; alert(&quot;不能大于5M&quot;); target.value=&quot;&quot;; return; &#125; $.ajaxFileUpload(&#123; url : &quot;$&#123;basePath&#125;webservicesys/orgAction!upFile.action&quot;, secureuri : false, fileElementId : &quot;uploadInput&quot;, dataType : &apos;json&apos;, success : function(result) &#123; console.log(result); if(result.code == 0) &#123; imgeUrl = result.data.url; upDataImge(result.data.url); &#125;else&#123; alert(result.desc); &#125; &#125;, error : function(data, status, e) &#123; console.log(e); alert(&quot;上传文件失败&quot;); &#125; &#125;); &#125; 后台代码本项目接口跳转存入文件服务器12345678910111213141516171819202122232425262728/** * 文件上传 * * @throws Exception * @throws BaseException */ @JSONOut(catchException = @CatchException(errCode = &quot;1005&quot;, successMsg = &quot;操作成功&quot;, faileMsg = &quot;操作失败&quot;)) public void upFile() throws Exception, BaseException &#123; try &#123; if (AssertUtil.isEmpty(upload)) &#123; setActionResult(&quot;1001&quot;, &quot;您导入的文件为空！&quot;); &#125; else &#123; System.out.println(upload.getName()+&quot;-------&quot;+upload.length()); System.out.println(uploadFileName+&quot;-------&quot;+uploadContetnType); String mrePosen = HttPostContent.SubmitPost(upload,uploadFileName); if (VerifyUtil.isEmpty(mrePosen)) &#123; setActionResult(&quot;1001&quot;, &quot;文件上传远程失败&quot;); &#125; else &#123; FileUpBean fileUpBean = JsonUtils.parseJson2Obj(mrePosen, FileUpBean.class); fileUpBean.initUrl(); System.out.println(&quot;fileLoadUrl:&quot;+new Gson().toJson(fileUpBean)); JqDataTable.doOutObject(fileUpBean); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 上传文件服务器1234567891011121314151617181920212223242526272829303132333435363738394041// file1与file2在同一个文件夹下 filepath是该文件夹指定的路径 public static String SubmitPost(File file,String fileName) &#123; HttpClient httpclient = new DefaultHttpClient(); try &#123; HttpPost httppost = new HttpPost(ConfigPath.getInstance().getFilePath()); FileBody bin = new FileBody(file); StringBody comment = new StringBody(fileName,Charset.forName(&quot;UTF-8&quot;)); MultipartEntity reqEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE, null, Charset.forName(&quot;UTF-8&quot;)); reqEntity.addPart(&quot;file&quot;, bin);// file1为请求后台的File upload;属性 reqEntity.addPart(&quot;fileName&quot;,comment);// filename1为请求后台的普通参数;属性 httppost.setEntity(reqEntity); HttpResponse response = httpclient.execute(httppost); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == HttpStatus.SC_OK) &#123; System.out.println(&quot;服务器正常响应.....&quot;); HttpEntity resEntity = response.getEntity(); String data = EntityUtils.toString(resEntity, &quot;UTF-8&quot;); System.out.println(&quot;原生返回数据：&quot;+data); JSONObject js = JSONObject.fromObject(data); System.out.println(&quot;json:&quot;+js); System.out.println(&quot;resEntity:&quot;+data);// httpclient自带的工具类读取返回数据 System.out.println(&quot;content:&quot;+resEntity.getContent()); EntityUtils.consume(resEntity); return data; &#125; &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.getConnectionManager().shutdown(); &#125; catch (Exception ignore) &#123; &#125; &#125; return &quot;&quot;; &#125; 文件服务器项目源码接收文件接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@ResponseBody @RequestMapping(&quot;upFile&quot;) public JSONObject upVersionFile(@RequestParam(&quot;file&quot;) CommonsMultipartFile[] files, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String mfileName = request.getParameter(&quot;fileName&quot;); for (int i = 0; i &lt; files.length; i++) &#123; log.error(&quot;fileName----------&gt;&quot; + files[i].getOriginalFilename()+&quot;---&quot;+mfileName); &#125; String savePath = ConfigPath.getInstance().getFilePath(); File file = new File(savePath); if(!file.exists())&#123; file.mkdirs(); &#125; for (int i = 0; i &lt; files.length; i++) &#123; System.out.println(&quot;fileName----------&gt;&quot; + files[i].getOriginalFilename()); if (!files[i].isEmpty()) &#123; int pre = (int) System.currentTimeMillis(); try &#123; String fileId = Constants.clearFileName(mfileName); String fileName =pre+fileId; FileUtils.copyInputStreamToFile(files[i].getInputStream(), new File(savePath,fileName)); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;fileName&quot;, mfileName); map.put(&quot;fileSize&quot;, files[i].getSize()); map.put(&quot;fileId&quot;, fileName); map.put(&quot;fileType&quot;, 1); String reData = new Gson().toJson(map); log.error(reData); return JSONObject.parseObject(reData); &#125; catch (Exception e) &#123; e.printStackTrace(); log.error(&quot;上传出错&quot;); &#125; &#125; &#125; return null; &#125; /** * 去除特殊符号 * @param fileName * @return */ public static String clearFileName(String fileName)&#123; String newFileName = fileName.replace(&quot;=&quot;, &quot;&quot;) .replace(&quot;@&quot;, &quot;&quot;) .replace(&quot;#&quot;,&quot;&quot;) .replace(&quot;$&quot;,&quot;&quot;) .replace(&quot;%&quot;,&quot;&quot;) .replace(&quot;……&quot;,&quot;&quot;) .replace(&quot;^&quot;,&quot;&quot;) .replace(&quot;&amp;&quot;,&quot;&quot;) .replace(&quot;，&quot;,&quot;&quot;) .replace(&quot;,&quot;,&quot;&quot;) .replace(&quot;。&quot;,&quot;&quot;) .replace(&quot;-&quot;,&quot;&quot;) .replace(&quot;_&quot;,&quot;&quot;) .replace(&quot;?&quot;,&quot;&quot;) .replace(&quot;（&quot;,&quot;&quot;) .replace(&quot;）&quot;,&quot;&quot;) .replace(&quot;(&quot;,&quot;&quot;) .replace(&quot;)&quot;,&quot;&quot;) .replace(&quot;*&quot;,&quot;&quot;); return newFileName; &#125; 文件下载接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@ResponseBody@RequestMapping(&quot;downLoad&quot;)public HttpServletResponse download(HttpServletResponse response,String fileName) throws UnsupportedEncodingException &#123; System.out.println(&quot;fileName:&quot;+fileName); String bname = new String(fileName.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;); System.out.println(&quot;bname：&quot;+bname); try &#123; InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;config.properties&quot;); Properties properties = new Properties(); try &#123; properties.load(inputStream); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; String savePath = properties.getProperty(&quot;FilePath&quot;); String path = savePath+&quot;/&quot;+bname; try &#123; // path是指欲下载的文件的路径。 File file = new File(path); // 取得文件名。 String filename = file.getName(); // 取得文件的后缀名。 String ext = filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1).toUpperCase(); // 以流的形式下载文件。 InputStream fis = new BufferedInputStream(new FileInputStream(path)); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); // 设置response的Header response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(filename.getBytes())); response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length()); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); response.setContentType(&quot;application/octet-stream&quot;); toClient.write(buffer); toClient.flush(); toClient.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return response; &#125; catch (Exception e) &#123; log.error(&quot;下载失败：-&quot; + e.getMessage(), e); return response; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tomcat配置之内存配置]]></title>
      <url>%2F2017%2F05%2F18%2Fpro%2Ftomcat%E9%85%8D%E7%BD%AE%E5%86%85%E5%AD%98%2F</url>
      <content type="text"><![CDATA[tomcat 配置内存 进入tomcat bin目录windows下找到 配置如下 找到cd ..set “CATALINA_HOME=%cd%”在后面添加上 set JAVA_OPTS=-Xms256m -Xmx512m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m -Djava.awt.headless=true 修改tomcat title 在catalina.bat 中添加 set title=8081[%DATE%] 即可效果如下 总结Linux下修改JVM内存大小:要添加在tomcat 的bin 下catalina.sh 里，位置cygwin=false前 。注意引号要带上,红色的为新添加的.123# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS=&quot;-Xms256m -Xmx512m -Xss1024K -XX:PermSize=128m -XX:MaxPermSize=256m&quot;cygwin=false windows下修改JVM内存大小:情况一:解压版本的Tomcat, 要通过startup.bat启动tomcat才能加载配置要添加在tomcat 的bin 下catalina.bat 里123rem Guess CATALINA_HOME if not definedset CURRENT_DIR=%cd%后面添加,红色的为新添加的.set JAVA_OPTS=-Xms256m -Xmx512m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m -Djava.awt.headless=true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis 自动生成dao与po bean]]></title>
      <url>%2F2017%2F05%2F11%2Fpro%2Fmybatis%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[mybatis自动生成代码工具 使用mybatis自动生成代码工具 首先连接到数据库 映射数据生成文件到本地 1.新建一个maven项目 在pom.xml 文件中导入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.star.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mybatis-generator&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;mybatis-generator&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 2.配置generatorConfig.xml文件 在resource中新建一个generatorConfig.xml xml文件 配置如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location=&quot;F:/work/java/project/base_sdk/qq/ojdbc14-10.2.0.4.0.jar&quot; /&gt; &lt;context id=&quot;my&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot; connectionURL=&quot;jdbc:mysql:@localhost:3306&quot; userId=&quot;root&quot; password=&quot;&quot; /&gt; --&gt; &lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@10.10.xx.xxx:1521:xxxx&quot; userId=&quot;c##xxxxx&quot; password=&quot;xxxx&quot; /&gt; &lt;!-- 配置生产po对象 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.aizhuwu.pro.main.po&quot; targetProject=&quot;F:\work\java\tab&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- mappring.xml 文件配置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.aizhuwu.pro.main.dao&quot; targetProject=&quot;F:\work\java\tab&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- DAO接口配置 --&gt; &lt;javaClientGenerator targetPackage=&quot;com.aizhuwu.pro.main.dao&quot; targetProject=&quot;F:\work\java\tab&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--&lt;table tableName=&quot;T_FEE_AGTBILL&quot; domainObjectName=&quot;FeeAgentBill&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&gt; --&gt; &lt;!-- 配置数据表 和 对应的 java对象名 多个表一起生成数据 就多个table标签 --&gt; &lt;table tableName=&quot;TB_DQDP_ORGANIZATION&quot; domainObjectName=&quot;Organization&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 12&lt;classPathEntry location=&quot;F:/work/java/project/base_sdk/qq/ojdbc14-10.2.0.4.0.jar&quot; /&gt; 改地址为oracle jdbc驱动包，如果是mysql则导入mysql 导入对应的驱动包即可 ###注意 oracle c12 账号特性是c##开头 用maven执行 mybatis-generator:generate 执行完后在配置的路径就可以看到对应的文件 接下来吧对应的文件考到项目中就可以使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何辨认你身边的真正的“聪明人”？]]></title>
      <url>%2F2017%2F04%2F24%2Fpro%2F%E8%BA%AB%E8%BE%B9%E8%81%AA%E6%98%8E%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[首先要明确的是一些基本原则。首先，具有特定领域的专业知识不代表聪明。比如一个下水道工人和一个挖掘机工人，各自都是各自职业领域的老手，哪个更聪明？这就不好说了。所以分辨的标准不应该是针对特定领域的，而应该是普适的。 再比如看学历，也不一定靠谱。我们抛开盖茨、乔布斯这些辍学的不谈，一个本科生和一个博士生哪个聪明？这也不好说，说不定本科生本科期间就做出了不错的科研成果，但是本科毕业没有继续做科研而直接去工作了，那他一定比博士生笨或者聪明吗？说不准的。 还有比如看出身，也不靠谱。因为个人经历和交友圈的关系，我周围的很多朋友都是名校出身，北清复交牛剑HYPS什么的很多，很多聚会上名校学生的数量远比非名校的多，那这种情况下出身本身就不具有太大的分辨性。虽然名校出来的普遍会让人觉得聪明点（具体原因可以参考下文），但是即使是同一个学校出来的人，也会有很容易被识别出来的聪明程度的差别。 那么我会通过什么来辨别聪明人呢？我有六个标准，两两一组分为基础指标，现实指标，和高层指标三个类别。基础、现实、高层的分类不是想说明轻重和高低，只是为了方便大家理解。 基础指标基础指标的第一个标准，是元认知（Metacognition）能力。 元认知能力，就是“对于认知的认知”和“关于知识的知识”，简单来说就是对于自我的认知过程的思考。关于元认知，网上有不少资料，大家可以通过搜索引擎找一下通俗的材料，感兴趣的也可以找相关的心理学文献读一下。 具有强元认知能力的人，通常表现是学习能力很强，因为他们对于自己的认知和学习过程很了解，能够在快速的自我思考和自省后产生出优化过的学习策略。 他们对自己的认知能力有较强的管控能力，懂得利用自己的认知能力的优势和已有知识框架来调节和评估新知识的摄入，这些人能够很快的把新知识融入到已有的知识当中。用乔布斯的话说，就是把已经划出的点连起来，而元认知能力高的人连得特别快。 ##基础指标的第二个标准，是有具有逻辑性的思维跳跃能力。 一般的交谈过程，通常就是先讲A，再讲B，再讲C，再讲D…… 但是我发觉，当和一些比较聪明的人聊天的时候，或者看其他的聪明人聊天的时候，通常不是一步一步走，而是跨着大步跳的，也就是先讲A，再讲D，再讲F，再讲J……这样。这种ADFJ的交谈方式，和前面的ABCD的交谈方式在逻辑上是一样的，并不是随机的思维跳跃，而是一些中间的逻辑步骤，因为交谈的双方都已经提前想到，并且一个眼神一个动作就心照不宣了，所以不需要每一步都讲一遍，直接说下一步就好了。 比如之前有个我觉得比我聪明好多的做医生的朋友来我家做客，我在厨房做饭，客人们在闲聊，中间聊到癌症的事情。我就想到个段子，然后说“骑摩托车戴安全帽也能增加得癌症的概率。”这个段子其实说的还是蛮直接的，我也觉得对方肯定听得懂，所以就没有补充或者继续讲，而那位医生朋友就直接回了一句“是啊，上次和主任一起去查房，主任就说其中一位老太太比其他病人更可能得癌症，因为she has the syndrome of having too many birthdays。”然后大家就会心一笑。 跟聪明程度相仿的人交谈起来跳跃的节奏是很舒适的，逻辑上也能很自然的过渡。但是如果两个人节奏差别过大，一方要经常说完A后补充说B和C才能继续说D，甚至中间还要加个B1、B2，那就是另外一种情况了。 现实指标现实指标的第一个标准，是好奇心。 其实，前面提到的元认知和思维跳跃，都属于聪明的下层建筑，而最能直观体现一个人是否聪明的标准是好奇心。 一个聪明人，通常是对生活中各种事情充满了广泛的好奇的，也正是这种好奇，让他有更多的机会获得新的知识。 好奇心和聪明程度是个鸡和蛋的情况。一个人的学习能力再强，如果好奇心不够，那他也不会去了解各种新东西；而如果一个人缺乏对事物的广泛了解，他就很难看到那些自己不理解的东西，也就不容易产生较强的好奇心。 用苏格拉底的话说，“我唯一知道的事，就是我一无所知。” 现实指标的第二个标准，是用简单的语言解释复杂的问题的能力。 经常能在包括知乎等网络社区，看到一些专业人士解释专业的或者技术性的问题，他们会很热心的花很多时间讲问题背后的原理，列出各种外行人很难看懂的公式、推导过程和专业术语，自己解答的很辛苦，读者大多没看懂，双方都不开心——“我都花了这么多功夫讲了你们怎么还是听不懂”和“你讲了这么一大堆不明觉厉，我还是不懂。” 而我接触到的一些很聪明的人，很多都在自己的专业领域有深入的研究，而这些聪明人的共同特点是在解释专业问题时会刻意避免使用别人可能听不懂的大词、黑话和专业用语。 刻意的选用简单的语言，至少说明两个问题，一是说话的人懂得换位思考，能够从对方角度分析和评价自己的表达，是对于知识的学习具有评估能力的体现；其次，很多专业用语和大词其实是专家直接沟通的工具，当你面对的听众不是专家的时候，你就不能用这些工具“偷懒”，这样对于说话者的要求就更高了，对于知识掌握程度的要求也更高。知乎上的一些比较有名的心理学、统计学、健身等等专业领域的用户，解答问题时通常都有这样的特点。 有个很有意思的年度科普活动叫作火焰挑战（flame challenge），组织方每年会出一个题目，然后要求参赛者制作一个视频，把这个题目用一个11岁小孩能听懂的话解释清楚。听起来很有趣，但是做起来还是很难的，历年的题目有“火焰是什么”、“颜色是什么”等。各位可以试试自己解释下“火焰是什么”这个题目，然后想一下你的解释能不能让一个11岁的小孩听懂。知乎上就有类似的题目，各位可以去看看那些题目下的回答是不是用简单的语言说清楚了的。 高层指标高层指标的第一个标准，是对于观点的态度。 具体表现在几个方面，比如对于自己不了解的领域少发表观点，这其实是上面说到的懂得越多越有好奇心的一种侧面体现；还有就是能够容纳不同的观点，甚至完全相反的观点，这其实是上面提到的换位思考能力的一种侧面体现；还有就是不迷信、不执迷不悟，当新的信息和证据证明自己原来的观点是错误的时候，能够改变自己的观点。 这几点说起来不难，其实大家都会说，但是自身做起来的时候真的蛮难的，因为这还要涉及到情商、面子等社交属性。 高层指标的第二个标准，是对于别人的态度。 一个人是不是善良，是很重要的一个标准。当然，准确的来说，善良并不代表聪明，聪明的坏人多了去了，事实上，想要做一个成功的坏人，也是需要聪明的，不够聪明的话坏事都做不到太大。 但是“好人”和“坏人”是很主观的判断。通常情况下，每个人在自己心中都是好人，连恐怖份子都不把自己当坏人的，他们在自己眼中是自由斗士和真理的捍卫者，是非常“高尚”的。 所以我说的善良，其实是对于别人的态度，就是说他是否能够通过分享、辅导、以身作则等方式帮助别人改善和提高，达成共赢的局面。帮助别人提高，想想都是极难的，大概是要把前面的五个标准都完成的差不多才能做到。 当然不能排除存在那些很聪明，但是坚持“不但我要成功，而且我要别人都失败”的人，不过这种人我还真是不感兴趣，这样的人是不是聪明无所谓，我总是会尽量避免的。 文章来源：知乎 文|谢熊猫君]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android均匀显示textview]]></title>
      <url>%2F2017%2F04%2F16%2Fpro%2Fandroid%2Ftext%E5%88%86%E5%B8%83%2F</url>
      <content type="text"><![CDATA[均匀分布textview 许多情况下，我们需要把文字均匀分布而且要保持几个空间的宽度一致。并且Android里又没有这种控或者属性风格之类 可以用空格来实现，但是空格会对不齐，字体大小改变后就不准确，基本无法实现功能。 在这里我给大家分享一个我自己写的控件，可以原理很简单是用画笔和画板将文字画出来，先看效果图如下，文章后面有控件下载地址需要的童鞋可以下载使用 使用非常简单，与textview使用方法一致 只需settext()即可 他的原理就是先获取文字数量，用控件的宽度来除以文字数量为宽度差，然后对应画出文字，降文字转化为数组，对应数组指针乘以宽度减去文字本身的宽度的一半，第一个文字和最后一个文字进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LineTextView extends TextView &#123; private Context context; private int viewWidth; private int viewHight; private int oneWidth; private int oneHight; private int num; private Paint p; private String str; private String[] texts; private int textSize = 15; public LineTextView(Context context) &#123; super(context); this.context = context; init(); &#125; public LineTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; init(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); init(); drawText(canvas); &#125; private void drawText(Canvas canvas) &#123; if (num == 0) return; int lineWidth = viewWidth / num; int drawY = (viewHight - oneHight) / 2 + oneHight; for (int i = 0; i &lt; num; i++) &#123; if (i == num - 1) &#123;// 最后一个 canvas.drawText(texts[i], viewWidth - oneWidth - dip2px(context, 2), drawY, p); &#125; else if (i != 0 &amp;&amp; i != num - 1) &#123;// canvas.drawText(texts[i], i * lineWidth + lineWidth / 2 - oneWidth / 2, drawY, p); &#125; else &#123;// 第一个 canvas.drawText(texts[i], i * lineWidth + dip2px(context, 2), drawY, p); &#125; &#125; &#125; private void init() &#123; this.setPadding(0, 0, 0, 0); viewWidth = this.getWidth(); viewHight = this.getHeight(); &#125; public void setText(String str) &#123; if (str == null) return; p = new Paint(); p.setColor(context.getResources().getColor(R.color.m_black)); p.setTextSize(dip2px(context, textSize)); this.str = str; num = str.length(); int width = ce(&quot;汉&quot;).width(); this.oneWidth = width; this.oneHight = ce(str).height(); String[] strs = new String[num]; for (int i = 0; i &lt; num; i++) &#123; strs[i] = str.substring(i, i + 1); &#125; this.texts = strs; this.invalidate(); &#125; public void setTestSize(int size) &#123; this.textSize = size; if (str != null) setText(str); &#125; public Rect ce(String str) &#123; Rect rect = new Rect(); p.getTextBounds(str, 0, 1, rect); return rect; &#125; /** * 根据手机的分辨率�? dp 的单�? 转成�? px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; 下载地址 http://pan.baidu.com/s/1eRZh8ki]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[api markdown 文档模板]]></title>
      <url>%2F2017%2F04%2F16%2Fpro%2Fapidoc%2F</url>
      <content type="text"><![CDATA[修改历史 日期 内容 2016-11-04 增加8根据群id查询群 2016-11-05 7接口增加group_desc字段 约束 约束 描述 ? 非必要参数 1 必要参数 2 并集关系，非必要，但是必须有一个 数据结构 12&gt; &#123;&quot;msg&quot;:&#123;&quot;code&quot;:&quot;0000&quot;,&quot;msg&quot;:&quot;请求成功&quot;&#125;,&quot;data&quot;:&#123;&#125;&#125;&gt; 1.列表账号和群组信息查询 im/imAction!findAcctount.action输入参数 参数名称 参数名 类型 所属类 约束 描述 群组id列表 groupRows list 2 群组id列表 联系人id列表 memberRows list 2 联系人id列表 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 账号列表 memberRows list data ? 账号id id String ImAcctountBean ? 手机号码 mobile String ImAcctountBean ? 头像 head_url String ImAcctountBean ? 别名 nick String ImAcctountBean ? 账号 account String ImAcctountBean ? 性别 sex String ImAcctountBean ? 1.男2.女 年龄 age String ImAcctountBean ? 身高 height String ImAcctountBean ? 居住地 residence String ImAcctountBean ? 群组id列表 groupRows list data ? 活动id activity_id String ImGroupBean ? 群id group_id String ImGroupBean ? 群创建时间 create_time String ImGroupBean ? 群名称 group_name String ImGroupBean ? 群简介 group_desc String ImGroupBean ? 群头像 group_head String ImGroupBean ? 群成员 group_member List ImGroupBean ? 群主 account String ImGroupBean ? 2.根据活动id查询群是否存在 im/imAction!findActivityGroup.action输入参数 参数名称 参数名 类型 所属类 约束 描述 活动id activityId String 1 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 群组对象 groupData ImGroupBean data ? 活动id activity_id String ImGroupBean ? 群id group_id String ImGroupBean ? 群创建时间 create_time String ImGroupBean ? 群名称 group_name String ImGroupBean ? 群简介 group_desc String ImGroupBean ? 群头像 group_head String ImGroupBean ? 群成员 group_member List ImGroupBean ? 群主 account String ImGroupBean ? 3.根据活动id创建群组 im/imAction!createActivityGroup.action输入参数 参数名称 参数名 类型 所属类 约束 描述 群主 account String 1 活动id activityId String ? 群名称 groupName String 1 群简介 groupDesc String 1 群头像 groupHead String ? 群成员账号 groupMembers List 1 成员account 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 群组id groupId String data ? 4.根据手机号码模糊查询用户 im/imAction!findImMobile.action输入参数 参数名称 参数名 类型 所属类 约束 描述 手机号码关键字 mobile String 1 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 用户组 imAcctountBeans List data ? 账号id id String ImAcctountBean ? 手机号码 mobile String ImAcctountBean ? 头像 head_url String ImAcctountBean ? 别名 nick String ImAcctountBean ? 账号 account String ImAcctountBean ? 性别 sex String ImAcctountBean ? 1.男2.女 年龄 age String ImAcctountBean ? 身高 height String ImAcctountBean ? 居住地 residence String ImAcctountBean ? 5.获取群人员 im/imAction!getGroupMember.action输入参数 参数名称 参数名 类型 所属类 约束 描述 群id group_id String 1 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 账号列表 memberRows list data ? 账号id id String ImAcctountBean ? 手机号码 mobile String ImAcctountBean ? 头像 head_url String ImAcctountBean ? 别名 nick String ImAcctountBean ? 账号 account String ImAcctountBean ? 性别 sex String ImAcctountBean ? 1.男2.女 年龄 age String ImAcctountBean ? 身高 height String ImAcctountBean ? 居住地 residence String ImAcctountBean ? 6.批量添加群人员 im/imAction!addGroupMembers.action输入参数 参数名称 参数名 类型 所属类 约束 描述 群id group_id String 1 成员 memberRows List 1 需要添加的成员列表 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 7.修改群信息 im/imAction!updataGroupData.action输入参数 参数名称 参数名 类型 所属类 约束 描述 群id group_id String 1 群昵称 group_name String ? 群头像 group_head String ? 群简介 group_desc String ? 8.群id查询群 im/imAction!findGroupIdGroup.action输入参数 参数名称 参数名 类型 所属类 约束 描述 群组id group_id String 1 输出参数 参数名称 参数名 类型 所属类 约束 描述 data 群组对象 groupData ImGroupBean data ? 活动id activity_id String ImGroupBean ? 群id group_id String ImGroupBean ? 群创建时间 create_time String ImGroupBean ? 群名称 group_name String ImGroupBean ? 群简介 group_desc String ImGroupBean ? 群头像 group_head String ImGroupBean ? 群成员 group_member List ImGroupBean ? 群主 account String ImGroupBean ? 账号列表 memberRows list ImGroupBean ? 账号id id String ImAcctountBean ? 手机号码 mobile String ImAcctountBean ? 头像 head_url String ImAcctountBean ? 别名 nick String ImAcctountBean ? 账号 account String ImAcctountBean ? 性别 sex String ImAcctountBean ? 1.男2.女 年龄 age String ImAcctountBean ? 身高 height String ImAcctountBean ? 居住地 residence String ImAcctountBean ?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[身份证打开器连接html]]></title>
      <url>%2F2017%2F04%2F16%2Fpro%2Fidcard%2F</url>
      <content type="text"><![CDATA[华视 CVR-100U 身份证书卡机html的二次开发 华视打卡器，html界面二次开发。主要注意事项1.下载正确的驱动包以及开发sdk2.安装文件路径权限3.浏览器运行权限必须以管理员身份运行 详细教程 第一步 下载开发所需的文件 进入华视官网下载页这里是做html开发所以下载对应一下的文件 驱动包 运行包 下载解压后文件夹 驱动包根据自己电脑配置和需求安装对应的版本 安装运行包 在上一个步骤安装CVRDLL.exe 中可能会出现 所以都必须使用以管理员的身份运行 第二步运行demo 特别注意运行IDCArdREader.ocx 文件必须得用浏览器的ActiveX控件使用目前支持ActiveX控件的小编了解的只有ie，尝试了用chrome安装IE Tab Multi 使用但是结果是这样无法使用↓ 用ie浏览器打开demo后 天杀的最必须注意的一点，在这里耗了很长时间，费了很多脑细胞，打电话给客服和技术没有解决的问题就是 我和小伙伴翻了很多网站，咨询了客服一边又一遍。后来我们找到了win7的一台电脑尝试成功了 但是换到了另外一台win7电脑上尝试又出现了这个问题。这到底系统问题还是什么问题呢。 后来发现了一个特点，能成功运行windows上面都没有出现这个情况 这个是需要管理员权限。可以说是导致读取txt失败的原因就是权限了 所以打开ie浏览器的时候必须以管理员的权限打开 二次开发就可以调用他demo里面的代码，其实相当简单主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;body style=&quot;text-align: center&quot;&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;OBJECT classid=&quot;clsid:10946843-7507-44FE-ACE8-2B3483D179B7&quot; id=&quot;CVR_IDCard&quot; name=&quot;CVR_IDCard&quot; width=&quot;0&quot; height=&quot;0&quot; &gt;&lt;/OBJECT&gt; &lt;script language=&quot;javascript&quot; type =&quot;text/javascript&quot;&gt; function ClearForm() &#123; document.all[&apos;Name&apos;].value = &quot;&quot;; document.all[&apos;Sex&apos;].value = &quot;&quot;; document.all[&apos;Nation&apos;].value = &quot;&quot;; document.all[&apos;Born&apos;].value = &quot;&quot;; document.all[&apos;Address&apos;].value = &quot;&quot;; document.all[&apos;CardNo&apos;].value = &quot;&quot;; document.all[&apos;IssuedAt&apos;].value = &quot;&quot;; document.all[&apos;EffectedDate&apos;].value = &quot;&quot;; document.all[&apos;ExpiredDate&apos;].value = &quot;&quot;; document.all[&apos;SAMID&apos;].value = &quot;&quot;; document.all[&apos;pic&apos;].src = &quot;&quot;; document.all[&apos;Picture&apos;].value = &quot;&quot;; document.all[&apos;PictureLen&apos;].value = &quot;&quot;; return true;&#125;function Button1_onclick() &#123; var CVR_IDCard = document.getElementById(&quot;CVR_IDCard&quot;); var strReadResult = CVR_IDCard.ReadCard(); if(strReadResult == &quot;0&quot;) &#123;ClearForm(); document.all[&apos;Name&apos;].value = CVR_IDCard.Name; document.all[&apos;Sex&apos;].value = CVR_IDCard.Sex; document.all[&apos;Nation&apos;].value = CVR_IDCard.Nation; document.all[&apos;Born&apos;].value = CVR_IDCard.Born; document.all[&apos;Address&apos;].value = CVR_IDCard.Address; document.all[&apos;CardNo&apos;].value = CVR_IDCard.CardNo; document.all[&apos;IssuedAt&apos;].value = CVR_IDCard.IssuedAt; document.all[&apos;EffectedDate&apos;].value = CVR_IDCard.EffectedDate; document.all[&apos;ExpiredDate&apos;].value = CVR_IDCard.ExpiredDate; document.all[&apos;SAMID&apos;].value = CVR_IDCard.SAMID; document.all[&apos;pic&apos;].src = CVR_IDCard.Pic; document.all[&apos;Picture&apos;].value = CVR_IDCard.Picture; document.all[&apos;PictureLen&apos;].value = CVR_IDCard.PictureLen &#125; else &#123; ClearForm(); alert(strReadResult); &#125; &#125; 运行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[日志封装]]></title>
      <url>%2F2017%2F04%2F15%2Fpro%2Fandroid%2Flog%2F</url>
      <content type="text"><![CDATA[log 打印封装 log 打印对调至关重要，而android log打印只能打印字符串，而我们在调试中大部分都是java 对象。许多人使用toString 方法来打印，虽然这个方法可行，但是对象里又二级对象就不适用而且比较麻烦。接下来就介绍我封装的logA对象 ##使用gson配合打印 gson 不管是对象数据还是集合类可以很直观的打印json对象 长度换行，log打印有长度显示，如果超出长度则调用调用另一个打印 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void e(Object content) &#123; show(&quot;ee&quot;, content);&#125;public static void a(Object content) &#123; show(&quot;aa&quot;, content);&#125;public static void texta(String str)&#123; if (str == null) &#123; Log.i(&quot;aa&quot;, &quot;str==null&quot;); return; &#125; Log.i(&quot;aa&quot;, str);&#125;public static void i(Object content) &#123; show(&quot;ii&quot;, content);&#125;private static void show(String name, Object obj) &#123; if (obj == null) &#123; Log.i(name, &quot;str==null&quot;); return; &#125; String str = new Gson().toJson(obj); int index = 0; int maxLength = 3000; String sub; if (str.length() &lt; maxLength) &#123; Log.i(name, str); &#125; else &#123; int num = str.length() / maxLength + 1; for (int i = 0; i &lt; num; i++) &#123; if (num - 1 == i) &#123; Log.i(name, str.substring(i * maxLength, str.length())); &#125; else &#123; Log.i(name, str.substring(i * maxLength, (i + 1) * maxLength)); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gson]]></title>
      <url>%2F2017%2F04%2F15%2Fpro%2Fandroid%2Fgson%2F</url>
      <content type="text"><![CDATA[gson基本使用 gson json使用最频繁的工具在这里就不做过多的介绍只介绍一下基本使用和几个注意点 tojson将java对象转换为json123Gson gson = new Gson(); List persons = new ArrayList(); String str = gson.toJson(persons); fromjson将json字符串转换为实体对象123Gson提供了fromJson()方法来实现从Json字符串转化为到java实体的方法。 比如json字符串为：[&#123;“name”:”name0”,”age”:0&#125;] Person person = gson.fromJson(str, Person.class); 注意点在使用泛型转换时12345678910111213141516171819202122232425262728293031323334class GsonResponsePasare&lt;T&gt; implements ParameterizedType &#123; private final UtilsLog lg = UtilsLog.getLogger(GsonResponsePasare.class); public T deal(String response) &#123;// Type gsonType = new ParameterizedType() &#123;//...&#125;;//不建议该方式，推荐采用GsonResponsePasare实现ParameterizedType.因为getActualTypeArguments这里涉及获取GsonResponsePasare的泛型集合 Type gsonType = this; CommonResponse&lt;T&gt; commonResponse = new Gson().fromJson(response, gsonType); lg.e(&quot;Data is : &quot; + commonResponse.data, &quot;Class Type is : &quot; + commonResponse.data.getClass().toString()); return commonResponse.data; &#125; @Override public Type[] getActualTypeArguments() &#123; Class clz = this.getClass(); //这里必须注意在外面使用new GsonResponsePasare&lt;GsonResponsePasare.DataInfo&gt;()&#123;&#125;;实例化时必须带上&#123;&#125;,否则获取到的superclass为Object Type superclass = clz.getGenericSuperclass(); //getGenericSuperclass()获得带有泛型的父类 if (superclass instanceof Class) &#123; throw new RuntimeException(&quot;Missing type parameter.&quot;); &#125; ParameterizedType parameterized = (ParameterizedType) superclass; return parameterized.getActualTypeArguments(); &#125; @Override public Type getOwnerType() &#123; return null; &#125; @Override public Type getRawType() &#123; return CommonResponse.class; &#125; &#125; GsonBuilder基本配置 Gson g = new GsonBuilder().serializeNulls().setDateFormat(“yyyy-MM-dd hh:mm”).create();serializeNulls 设置此项对象为空也转换setDateFormat 将时间类型转换为对应格式的字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android定时缓存]]></title>
      <url>%2F2017%2F04%2F15%2Fpro%2Fandroid%2Fcache%2F</url>
      <content type="text"><![CDATA[定时缓存 给大家介绍一个比好好用轻量级缓存工具Acache,它类似javaEE的ehcache使用非常方便，可以设置自动过期时间 1234ACache mCache = ACache.get(this);mCache.put(&quot;test_key1&quot;, &quot;test value&quot;);mCache.put(&quot;test_key2&quot;, &quot;test value&quot;, 10);//保存10秒，如果超过10秒去获取这个key，将为nullmCache.put(&quot;test_key3&quot;, &quot;test value&quot;, 2 * ACache.TIME_DAY);//保存两天，如果超过两天去获取这个key，将为nul 使用起来就和使用map累死，key-value，第三个参数为是时间参数。如果设置了时间参数，则数据会将在超过该时间后自动清除如果没有设置时间参数，则数据会永久保存Acache可以完全代替sharedpreferences 使用，简介方便高效 Acache 下载文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单介绍封装技巧]]></title>
      <url>%2F2017%2F04%2F15%2Findex%2F</url>
      <content type="text"><![CDATA[android开发向导介绍 在开发中封装一些工具类对开发效率有极大的提示，下面就给大家介绍一些自己封装方法本文章简单介绍一些android开发工具类和学习路径 小编特别介绍封装神方法配合反射使用此乃封装利器12345泛型内部获取泛型类型Type type = getClass().getGenericSuperclass();Type trueType = ((ParameterizedType) type).getActualTypeArguments()[0];Class&lt;T&gt; cls = (Class&lt;T&gt;) trueType;LogA.e(cls.getClass());]]></content>
    </entry>

    
  
  
</search>
